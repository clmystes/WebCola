{"version":3,"file":"cola.umd.production.min.js","sources":["../src/powergraph.ts","../src/linklengths.ts","../src/descent.ts","../src/vpsc.ts","../src/rbtree.ts","../src/rectangle.ts","../src/pqueue.ts","../src/shortestpaths.ts","../src/geom.ts","../src/handledisconnected.ts","../src/layout.ts","../src/adaptor.ts","../src/d3v3adaptor.ts","../src/d3Nextadaptor.ts","../src/gridrouter.ts","../src/layout3d.ts","../src/d3adaptor.ts","../src/batch.ts"],"sourcesContent":["import {LinkAccessor} from './linklengths'\n\nexport interface LinkTypeAccessor<Link> extends LinkAccessor<Link> {\n        // return a unique identifier for the type of the link\n        getType(l: Link): number;\n    }\n\n    export class PowerEdge {\n        constructor(\n            public source: any,\n            public target: any,\n            public type: number) { }\n    }\n\n    export class Configuration<Link> {\n        // canonical list of modules.\n        // Initialized to a module for each leaf node, such that the ids and indexes of the module in the array match the indexes of the nodes in links\n        // Modules created through merges are appended to the end of this.\n        modules: Module[];\n        // top level modules and candidates for merges\n        roots: ModuleSet[];\n        // remaining edge count\n        R: number;\n        constructor(n: number, edges: Link[], private linkAccessor: LinkTypeAccessor<Link>, rootGroup?: any[]) {\n            this.modules = new Array(n);\n            this.roots = [];\n            if (rootGroup) {\n                this.initModulesFromGroup(rootGroup);\n            } else {\n                this.roots.push(new ModuleSet());\n                for (var i = 0; i < n; ++i)\n                    this.roots[0].add(this.modules[i] = new Module(i));\n            }\n            this.R = edges.length;\n            edges.forEach(e => {\n                var s = this.modules[linkAccessor.getSourceIndex(e)],\n                    t = this.modules[linkAccessor.getTargetIndex(e)],\n                    type = linkAccessor.getType(e);\n                s.outgoing.add(type, t);\n                t.incoming.add(type, s);\n            });\n        }\n\n        private initModulesFromGroup(group): ModuleSet {\n            var moduleSet = new ModuleSet();\n            this.roots.push(moduleSet);\n            for (var i = 0; i < group.leaves.length; ++i) {\n                var node = group.leaves[i];\n                var module = new Module(node.id);\n                this.modules[node.id] = module;\n                moduleSet.add(module);\n            }\n            if (group.groups) {\n                for (var j = 0; j < group.groups.length; ++j) {\n                    var child = group.groups[j];\n                    // Propagate group properties (like padding, stiffness, ...) as module definition so that the generated power graph group will inherit it\n                    var definition = {};\n                    for (var prop in child)\n                        if (prop !== \"leaves\" && prop !== \"groups\" && child.hasOwnProperty(prop))\n                            definition[prop] = child[prop];\n                    // Use negative module id to avoid clashes between predefined and generated modules\n                    moduleSet.add(new Module(-1-j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));\n                }\n            }\n            return moduleSet;\n         }\n\n        // merge modules a and b keeping track of their power edges and removing the from roots\n        merge(a: Module, b: Module, k: number = 0): Module {\n            var inInt = a.incoming.intersection(b.incoming),\n                outInt = a.outgoing.intersection(b.outgoing);\n            var children = new ModuleSet();\n            children.add(a);\n            children.add(b);\n            var m = new Module(this.modules.length, outInt, inInt, children);\n            this.modules.push(m);\n            var update = (s: LinkSets, i: string, o: string) => {\n                s.forAll((ms, linktype) => {\n                    ms.forAll(n => {\n                        var nls = <LinkSets>n[i];\n                        nls.add(linktype, m);\n                        nls.remove(linktype, a);\n                        nls.remove(linktype, b);\n                        (<LinkSets>a[o]).remove(linktype, n);\n                        (<LinkSets>b[o]).remove(linktype, n);\n                    });\n                });\n            };\n            update(outInt, \"incoming\", \"outgoing\");\n            update(inInt, \"outgoing\", \"incoming\");\n            this.R -= inInt.count() + outInt.count();\n            this.roots[k].remove(a);\n            this.roots[k].remove(b);\n            this.roots[k].add(m);\n            return m;\n        }\n\n        private rootMerges(k: number = 0): {\n            id: number;\n            nEdges: number;\n            a: Module;\n            b: Module;\n        }[] {\n            var rs = this.roots[k].modules();\n            var n = rs.length;\n            var merges = new Array(n * (n - 1));\n            var ctr = 0;\n            for (var i = 0, i_ = n - 1; i < i_; ++i) {\n                for (var j = i+1; j < n; ++j) {\n                    var a = rs[i], b = rs[j];\n                    merges[ctr] = { id: ctr, nEdges: this.nEdges(a, b), a: a, b: b };\n                    ctr++;\n                }\n            }\n            return merges;\n        }\n\n        greedyMerge(): boolean {\n            for (var i = 0; i < this.roots.length; ++i) {\n                // Handle single nested module case\n                if (this.roots[i].modules().length < 2) continue;\n\n                // find the merge that allows for the most edges to be removed.  secondary ordering based on arbitrary id (for predictability)\n                var ms = this.rootMerges(i).sort((a, b) => a.nEdges == b.nEdges ? a.id - b.id : a.nEdges - b.nEdges);\n                var m = ms[0];\n                if (m.nEdges >= this.R) continue;\n                this.merge(m.a, m.b, i);\n                return true;\n            }\n        }\n\n        private nEdges(a: Module, b: Module): number {\n            var inInt = a.incoming.intersection(b.incoming),\n                outInt = a.outgoing.intersection(b.outgoing);\n            return this.R - inInt.count() - outInt.count();\n        }\n\n        getGroupHierarchy(retargetedEdges: PowerEdge[]): any[]{\n            var groups = [];\n            var root = {};\n            toGroups(this.roots[0], root, groups);\n            var es = this.allEdges();\n            es.forEach(e => {\n                var a = this.modules[e.source];\n                var b = this.modules[e.target];\n                retargetedEdges.push(new PowerEdge(\n                    typeof a.gid === \"undefined\" ? e.source : groups[a.gid],\n                    typeof b.gid === \"undefined\" ? e.target : groups[b.gid],\n                    e.type\n                ));\n            });\n            return groups;\n        }\n\n        allEdges(): PowerEdge[] {\n            var es = [];\n            Configuration.getEdges(this.roots[0], es);\n            return es;\n        }\n\n        static getEdges(modules: ModuleSet, es: PowerEdge[]) {\n            modules.forAll(m => {\n                m.getEdges(es);\n                Configuration.getEdges(m.children, es);\n            });\n        }\n    }\n\n    function toGroups(modules: ModuleSet, group, groups) {\n        modules.forAll(m => {\n            if (m.isLeaf()) {\n                if (!group.leaves) group.leaves = [];\n                group.leaves.push(m.id);\n            } else {\n                var g = group;\n                m.gid = groups.length;\n                if (!m.isIsland() || m.isPredefined()) {\n                    g = { id: m.gid };\n                    if (m.isPredefined())\n                        // Apply original group properties\n                        for (var prop in m.definition)\n                            g[prop] = m.definition[prop];\n                    if (!group.groups) group.groups = [];\n                    group.groups.push(m.gid);\n                    groups.push(g);\n                }\n                toGroups(m.children, g, groups);\n            }\n        });\n    }\n\n    export class Module {\n        gid: number;\n\n        constructor(\n            public id: number,\n            public outgoing: LinkSets = new LinkSets(),\n            public incoming: LinkSets = new LinkSets(),\n            public children: ModuleSet = new ModuleSet(),\n            public definition?: any) { }\n\n        getEdges(es: PowerEdge[]) {\n            this.outgoing.forAll((ms, edgetype) => {\n                ms.forAll(target => {\n                    es.push(new PowerEdge(this.id, target.id, edgetype));\n                });\n            });\n        }\n\n        isLeaf() {\n            return this.children.count() === 0;\n        }\n\n        isIsland() {\n            return this.outgoing.count() === 0 && this.incoming.count() === 0;\n        }\n\n        isPredefined(): boolean {\n            return typeof this.definition !== \"undefined\";\n        }\n    }\n\n    function intersection(m: any, n: any): any {\n        var i = {};\n        for (var v in m) if (v in n) i[v] = m[v];\n        return i;\n    }\n\n    export class ModuleSet {\n        table: any = {};\n        count() {\n            return Object.keys(this.table).length;\n        }\n        intersection(other: ModuleSet): ModuleSet {\n            var result = new ModuleSet();\n            result.table = intersection(this.table, other.table);\n            return result;\n        }\n        intersectionCount(other: ModuleSet): number {\n            return this.intersection(other).count();\n        }\n        contains(id: number): boolean {\n            return id in this.table;\n        }\n        add(m: Module): void {\n            this.table[m.id] = m;\n        }\n        remove(m: Module): void {\n            delete this.table[m.id];\n        }\n        forAll(f: (m: Module) => void) {\n            for (var mid in this.table) {\n                f(this.table[mid]);\n            }\n        }\n        modules(): Module[] {\n            var vs = [];\n            this.forAll(m => {\n                if (!m.isPredefined())\n                    vs.push(m);\n            });\n            return vs;\n        }\n    }\n\n    export class LinkSets {\n        sets: any = {};\n        n: number = 0;\n        count(): number {\n            return this.n;\n        }\n        contains(id: number) {\n            var result = false;\n            this.forAllModules(m => {\n                if (!result && m.id == id) {\n                    result = true;\n                }\n            });\n            return result;\n        }\n        add(linktype: number, m: Module) {\n            var s: ModuleSet = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();\n            s.add(m);\n            ++this.n;\n        }\n        remove(linktype: number, m: Module) {\n            var ms = <ModuleSet>this.sets[linktype];\n            ms.remove(m);\n            if (ms.count() === 0) {\n                delete this.sets[linktype];\n            }\n            --this.n;\n        }\n        forAll(f: (ms: ModuleSet, linktype: number) => void) {\n            for (var linktype in this.sets) {\n                f(<ModuleSet>this.sets[linktype], Number(linktype));\n            }\n        }\n        forAllModules(f: (m: Module) => void) {\n            this.forAll((ms, lt) => ms.forAll(f));\n        }\n        intersection(other: LinkSets): LinkSets {\n            var result: LinkSets = new LinkSets();\n            this.forAll((ms, lt) => {\n                if (lt in other.sets) {\n                    var i = ms.intersection(other.sets[lt]),\n                        n = i.count();\n                    if (n > 0) {\n                        result.sets[lt] = i;\n                        result.n += n;\n                    }\n                }\n            });\n            return result;\n        }\n    }\n\n    function intersectionCount(m: any, n: any): number {\n        return Object.keys(intersection(m, n)).length\n    }\n\n    export function getGroups<Link>(nodes: any[], links: Link[], la: LinkTypeAccessor<Link>, rootGroup?: any[]): { groups: any[]; powerEdges: PowerEdge[] } {\n        var n = nodes.length,\n            c = new Configuration(n, links, la, rootGroup);\n        while (c.greedyMerge());\n        var powerEdges: PowerEdge[] = [];\n        var g = c.getGroupHierarchy(powerEdges);\n        powerEdges.forEach(function (e) {\n            var f = (end) => {\n                var g = e[end];\n                if (typeof g == \"number\") e[end] = nodes[g];\n            };\n            f(\"source\");\n            f(\"target\");\n        });\n        return { groups: g, powerEdges: powerEdges };\n    }\n","    export interface LinkAccessor<Link> {\n        getSourceIndex(l: Link): number;\n        getTargetIndex(l: Link): number;\n    }\n\n    export interface LinkLengthAccessor<Link> extends LinkAccessor<Link> {\n        setLength(l: Link, value: number): void;\n    }\n\n    // compute the size of the union of two sets a and b\n    function unionCount(a: any, b: any): number {\n        var u = {};\n        for (var i in a) u[i] = {};\n        for (var i in b) u[i] = {};\n        return Object.keys(u).length;\n    }\n\n    // compute the size of the intersection of two sets a and b\n    function intersectionCount(a: number[], b: number[]): number {\n        var n = 0;\n        for (var i in a) if (typeof b[i] !== 'undefined') ++n;\n        return n;\n    }\n\n    function getNeighbours<Link>(links: Link[], la: LinkAccessor<Link>): any {\n        var neighbours = {};\n        var addNeighbours = (u, v) => {\n            if (typeof neighbours[u] === 'undefined')\n                neighbours[u] = {};\n            neighbours[u][v] = {};\n        };\n        links.forEach(e => {\n            var u = la.getSourceIndex(e), v = la.getTargetIndex(e);\n            addNeighbours(u, v);\n            addNeighbours(v, u);\n        });\n        return neighbours;\n    }\n\n    // modify the lengths of the specified links by the result of function f weighted by w\n    function computeLinkLengths<Link>(links: Link[], w: number, f: (a: any, b: any) => number, la: LinkLengthAccessor<Link>) {\n        var neighbours = getNeighbours(links, la);\n        links.forEach(l => {\n            var a = neighbours[la.getSourceIndex(l)];\n            var b = neighbours[la.getTargetIndex(l)];\n            la.setLength(l, 1 + w * f(a, b));\n        });\n    }\n\n    /** modify the specified link lengths based on the symmetric difference of their neighbours\n     * @class symmetricDiffLinkLengths\n     */\n    export function symmetricDiffLinkLengths<Link>(links: Link[], la: LinkLengthAccessor<Link>, w: number = 1) {\n        computeLinkLengths(links, w, (a, b) => Math.sqrt(unionCount(a, b) - intersectionCount(a, b)), la);\n    }\n\n    /** modify the specified links lengths based on the jaccard difference between their neighbours\n     * @class jaccardLinkLengths\n     */\n    export function jaccardLinkLengths<Link>(links: Link[], la: LinkLengthAccessor<Link>, w: number = 1) {\n        computeLinkLengths(links, w, (a, b) =>\n            Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b)\n            , la);\n    }\n\n    export interface IConstraint {\n        left: number;\n        right: number;\n        gap: number;\n    }\n\n    export interface DirectedEdgeConstraints {\n        axis: string;\n        gap: number;\n    }\n\n    export interface LinkSepAccessor<Link> extends LinkAccessor<Link> {\n        getMinSeparation(l: Link): number;\n    }\n\n    /** generate separation constraints for all edges unless both their source and sink are in the same strongly connected component\n     * @class generateDirectedEdgeConstraints\n     */\n    export function generateDirectedEdgeConstraints<Link>(n: number, links: Link[], axis: string,\n        la: LinkSepAccessor<Link>): IConstraint[]\n    {\n        var components = stronglyConnectedComponents(n, links, la);\n        var nodes = {};\n        components.forEach((c,i) =>\n            c.forEach(v => nodes[v] = i)\n        );\n        var constraints: any[] = [];\n        links.forEach(l => {\n            var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l),\n                u = nodes[ui], v = nodes[vi];\n            if (u !== v) {\n                constraints.push({\n                    axis: axis,\n                    left: ui,\n                    right: vi,\n                    gap: la.getMinSeparation(l)\n                });\n            }\n        });\n        return constraints;\n    }\n\n    /**\n     * Tarjan's strongly connected components algorithm for directed graphs\n     * returns an array of arrays of node indicies in each of the strongly connected components.\n     * a vertex not in a SCC of two or more nodes is it's own SCC.\n     * adaptation of https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n     */\n    export function stronglyConnectedComponents<Link>(numVertices: number, edges: Link[], la: LinkAccessor<Link>): number[][]{\n        var nodes = [];\n        var index = 0;\n        var stack = [];\n        var components = [];\n        function strongConnect(v) {\n            // Set the depth index for v to the smallest unused index\n            v.index = v.lowlink = index++;\n            stack.push(v);\n            v.onStack = true;\n\n            // Consider successors of v\n            for (var w of v.out) {\n                if (typeof w.index === 'undefined') {\n                    // Successor w has not yet been visited; recurse on it\n                    strongConnect(w);\n                    v.lowlink = Math.min(v.lowlink, w.lowlink);\n                } else if (w.onStack) {\n                    // Successor w is in stack S and hence in the current SCC\n                    v.lowlink = Math.min(v.lowlink, w.index);\n                }\n            }\n\n            // If v is a root node, pop the stack and generate an SCC\n            if (v.lowlink === v.index) {\n                // start a new strongly connected component\n                var component = [];\n                while (stack.length) {\n                    w = stack.pop();\n                    w.onStack = false;\n                    //add w to current strongly connected component\n                    component.push(w);\n                    if (w === v) break;\n                }\n                // output the current strongly connected component\n                components.push(component.map(v => v.id));\n            }\n        }\n        for (var i = 0; i < numVertices; i++) {\n            nodes.push({id: i, out: []});\n        }\n        for (var e of edges) {\n            let v = nodes[la.getSourceIndex(e)],\n                w = nodes[la.getTargetIndex(e)];\n            v.out.push(w);\n        }\n        for (var v of nodes) if (typeof v.index === 'undefined') strongConnect(v);\n        return components;\n    }\n","    /**\n     * Descent respects a collection of locks over nodes that should not move\n     * @class Locks\n     */\n    export class Locks {\n        locks: { [key:number]:number[]} = {};\n        /**\n         * add a lock on the node at index id\n         * @method add\n         * @param id index of node to be locked\n         * @param x required position for node\n         */\n        add(id: number, x: number[]) {\n/* DEBUG\n            if (isNaN(x[0]) || isNaN(x[1])) debugger;\nDEBUG */\n            this.locks[id] = x;\n        }\n        /**\n         * @method clear clear all locks\n         */\n        clear() {\n            this.locks = {};\n        }\n        /**\n         * @isEmpty\n         * @returns false if no locks exist\n         */\n        isEmpty(): boolean {\n            for (var l in this.locks) return false;\n            return true;\n        }\n        /**\n         * perform an operation on each lock\n         * @apply\n         */\n        apply(f: (id: number, x: number[]) => void) {\n            for (var l in this.locks) {\n                f(Number(l), this.locks[l]);\n            }\n        }\n    }\n\n    /**\n     * Uses a gradient descent approach to reduce a stress or p-stress goal function over a graph with specified ideal edge lengths or a square matrix of dissimilarities.\n     * The standard stress function over a graph nodes with position vectors x,y,z is (mathematica input):\n     *   stress[x_,y_,z_,D_,w_]:=Sum[w[[i,j]] (length[x[[i]],y[[i]],z[[i]],x[[j]],y[[j]],z[[j]]]-d[[i,j]])^2,{i,Length[x]-1},{j,i+1,Length[x]}]\n     * where: D is a square matrix of ideal separations between nodes, w is matrix of weights for those separations\n     *        length[x1_, y1_, z1_, x2_, y2_, z2_] = Sqrt[(x1 - x2)^2 + (y1 - y2)^2 + (z1 - z2)^2]\n     * below, we use wij = 1/(Dij^2)\n     *\n     * @class Descent\n     */\n    export class Descent {\n        public threshold: number = 0.0001;\n        /** Hessian Matrix\n         * @property H {number[][][]}\n         */\n        public H: number[][][];\n        /** gradient vector\n         * @property G {number[][]}\n         */\n        public g: number[][];\n        /** positions vector\n         * @property x {number[][]}\n         */\n        public x: number[][];\n        /**\n         * @property k {number} dimensionality\n         */\n        public k: number;\n        /**\n         * number of data-points / nodes / size of vectors/matrices\n         * @property n {number}\n         */\n        public n: number;\n\n        public locks: Locks;\n\n        private static zeroDistance: number = 1e-10;\n        private minD: number;\n\n        // pool of arrays of size n used internally, allocated in constructor\n        private Hd: number[][];\n        private a: number[][];\n        private b: number[][];\n        private c: number[][];\n        private d: number[][];\n        private e: number[][];\n        private ia: number[][];\n        private ib: number[][];\n        private xtmp: number[][];\n\n\n        // Parameters for grid snap stress.\n        // TODO: Make a pluggable \"StressTerm\" class instead of this\n        // mess.\n        public numGridSnapNodes: number = 0;\n        public snapGridSize: number = 100;\n        public snapStrength: number = 1000;\n        public scaleSnapByMaxH: boolean = false;\n\n        private random = new PseudoRandom();\n\n        public project: { (x0: number[], y0: number[], r: number[]): void }[] = null;\n\n        /**\n         * @method constructor\n         * @param x {number[][]} initial coordinates for nodes\n         * @param D {number[][]} matrix of desired distances between pairs of nodes\n         * @param G {number[][]} [default=null] if specified, G is a matrix of weights for goal terms between pairs of nodes.\n         * If G[i][j] > 1 and the separation between nodes i and j is greater than their ideal distance, then there is no contribution for this pair to the goal\n         * If G[i][j] <= 1 then it is used as a weighting on the contribution of the variance between ideal and actual separation between i and j to the goal function\n         */\n        constructor(x: number[][], public D: number[][], public G: number[][]= null) {\n            this.x = x;\n            this.k = x.length; // dimensionality\n            var n = this.n = x[0].length; // number of nodes\n            this.H = new Array(this.k);\n            this.g = new Array(this.k);\n            this.Hd = new Array(this.k);\n            this.a = new Array(this.k);\n            this.b = new Array(this.k);\n            this.c = new Array(this.k);\n            this.d = new Array(this.k);\n            this.e = new Array(this.k);\n            this.ia = new Array(this.k);\n            this.ib = new Array(this.k);\n            this.xtmp = new Array(this.k);\n            this.locks = new Locks();\n            this.minD = Number.MAX_VALUE;\n            var i = n, j;\n            while (i--) {\n                j = n;\n                while (--j > i) {\n                    var d = D[i][j];\n                    if (d > 0 && d < this.minD) {\n                        this.minD = d;\n                    }\n                }\n            }\n            if (this.minD === Number.MAX_VALUE) this.minD = 1;\n            i = this.k;\n            while (i--) {\n                this.g[i] = new Array(n);\n                this.H[i] = new Array(n);\n                j = n;\n                while (j--) {\n                    this.H[i][j] = new Array(n);\n                }\n                this.Hd[i] = new Array(n);\n                this.a[i] = new Array(n);\n                this.b[i] = new Array(n);\n                this.c[i] = new Array(n);\n                this.d[i] = new Array(n);\n                this.e[i] = new Array(n);\n                this.ia[i] = new Array(n);\n                this.ib[i] = new Array(n);\n                this.xtmp[i] = new Array(n);\n            }\n        }\n\n        public static createSquareMatrix(n: number, f: (i: number, j: number) => number): number[][] {\n            var M = new Array(n);\n            for (var i = 0; i < n; ++i) {\n                M[i] = new Array(n);\n                for (var j = 0; j < n; ++j) {\n                    M[i][j] = f(i, j);\n                }\n            }\n            return M;\n        }\n\n        private offsetDir(): number[] {\n            var u = new Array(this.k);\n            var l = 0;\n            for (var i = 0; i < this.k; ++i) {\n                var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;\n                l += x * x;\n            }\n            l = Math.sqrt(l);\n            return u.map(x=> x *= this.minD / l);\n        }\n\n        // compute first and second derivative information storing results in this.g and this.H\n        public computeDerivatives(x: number[][]) {\n            const n = this.n;\n            if (n < 1) return;\n            let i: number;\n/* DEBUG\n            for (var u: number = 0; u < n; ++u)\n                for (i = 0; i < this.k; ++i)\n                    if (isNaN(x[i][u])) debugger;\nDEBUG */\n\n            let d = new Array<number>(this.k); // distance vector\n            let d2 = new Array<number>(this.k); // distance vector squared\n            let Huu = new Array<number>(this.k); // Hessian diagonal\n            let maxH = 0; // max Hessian matrix entry\n\n            // across all nodes u\n            for (let u = 0; u < n; ++u) {\n                // zero gradient and hessian diagonals\n                for (i = 0; i < this.k; ++i) Huu[i] = this.g[i][u] = 0;\n\n                // across all nodes v\n                for (let v = 0; v < n; ++v) {\n                    if (u === v) continue;\n\n                    // The following loop computes distance vector and\n                    // randomly displaces nodes that are at identical positions\n                    let maxDisplaces = n; // avoid infinite loop in the case of numerical issues, such as huge values\n                    let distanceSquared = 0;\n                    while (maxDisplaces--) {\n                        distanceSquared = 0;\n                        for (i = 0; i < this.k; ++i) {\n                            const dx = d[i] = x[i][u] - x[i][v];\n                            distanceSquared += d2[i] = dx * dx;\n                        }\n                        if (distanceSquared > 1e-9) break;\n                        const rd = this.offsetDir();\n                        for (i = 0; i < this.k; ++i) x[i][v] += rd[i];\n                    }\n                    const distance = Math.sqrt(distanceSquared);\n                    const idealDistance = this.D[u][v];\n                    // weights are passed via G matrix.\n                    // weight > 1 means not immediately connected\n                    // small weights (<<1) are used for group dummy nodes\n                    let weight = this.G != null ? this.G[u][v] : 1;\n\n                    // ignore long range attractions for nodes not immediately connected (P-stress)\n                    if (weight > 1 && distance > idealDistance || !isFinite(idealDistance)) {\n                        for (i = 0; i < this.k; ++i) this.H[i][u][v] = 0;\n                        continue;\n                    }\n                    // weight > 1 was just an indicator - this is an arcane interface,\n                    // but we are trying to be economical storing and passing node pair info\n                    if (weight > 1) {\n                        weight = 1;\n                    }\n                    const idealDistSquared = idealDistance * idealDistance,\n                        gs = 2 * weight * (distance - idealDistance) / (idealDistSquared * distance),\n                        distanceCubed = distanceSquared * distance,\n                        hs = 2 * -weight / (idealDistSquared * distanceCubed);\n                    if (!isFinite(gs))\n                        console.log(gs);\n                    for (i = 0; i < this.k; ++i) {\n                        this.g[i][u] += d[i] * gs;\n                        Huu[i] -= this.H[i][u][v] = hs * (2 * distanceCubed + idealDistance * (d2[i] - distanceSquared));\n                    }\n                }\n                for (i = 0; i < this.k; ++i) maxH = Math.max(maxH, this.H[i][u][u] = Huu[i]);\n            }\n            // Grid snap forces\n            var r = this.snapGridSize/2;\n            var g = this.snapGridSize;\n            var w = this.snapStrength;\n            var k = w / (r * r);\n            var numNodes = this.numGridSnapNodes;\n            //var numNodes = n;\n            for (var u: number = 0; u < numNodes; ++u) {\n                for (i = 0; i < this.k; ++i) {\n                    var xiu = this.x[i][u];\n                    var m = xiu / g;\n                    var f = m % 1;\n                    var q = m - f;\n                    var a = Math.abs(f);\n                    var dx = (a <= 0.5) ? xiu - q * g :\n                        (xiu > 0) ? xiu - (q + 1) * g : xiu - (q - 1) * g;\n                    if (-r < dx && dx <= r) {\n                        if (this.scaleSnapByMaxH) {\n                            this.g[i][u] += maxH * k * dx;\n                            this.H[i][u][u] += maxH * k;\n                        } else {\n                            this.g[i][u] += k * dx;\n                            this.H[i][u][u] += k;\n                        }\n                    }\n                }\n            }\n            if (!this.locks.isEmpty()) {\n                this.locks.apply((u, p) => {\n                    for (i = 0; i < this.k; ++i) {\n                        this.H[i][u][u] += maxH;\n                        this.g[i][u] -= maxH * (p[i] - x[i][u]);\n                    }\n                });\n            }\n/* DEBUG\n            for (var u: number = 0; u < n; ++u)\n                for (i = 0; i < this.k; ++i) {\n                    if (isNaN(this.g[i][u])) debugger;\n                    for (var v: number = 0; v < n; ++v)\n                        if (isNaN(this.H[i][u][v])) debugger;\n                }\nDEBUG */\n        }\n\n        private static dotProd(a: number[], b: number[]): number {\n            var x = 0, i = a.length;\n            while (i--) x += a[i] * b[i];\n            return x;\n        }\n\n        // result r = matrix m * vector v\n        private static rightMultiply(m: number[][], v: number[], r: number[]) {\n            var i = m.length;\n            while (i--) r[i] = Descent.dotProd(m[i], v);\n        }\n\n        // computes the optimal step size to take in direction d using the\n        // derivative information in this.g and this.H\n        // returns the scalar multiplier to apply to d to get the optimal step\n        public computeStepSize(d: number[][]): number {\n            var numerator = 0, denominator = 0;\n            for (var i = 0; i < this.k; ++i) {\n                numerator += Descent.dotProd(this.g[i], d[i]);\n                Descent.rightMultiply(this.H[i], d[i], this.Hd[i]);\n                denominator += Descent.dotProd(d[i], this.Hd[i]);\n            }\n            if (denominator === 0 || !isFinite(denominator)) return 0;\n            return 1 * numerator / denominator;\n        }\n\n        public reduceStress(): number {\n            this.computeDerivatives(this.x);\n            var alpha = this.computeStepSize(this.g);\n            for (var i = 0; i < this.k; ++i) {\n                this.takeDescentStep(this.x[i], this.g[i], alpha);\n            }\n            return this.computeStress();\n        }\n\n        private static copy(a: number[][], b: number[][]): void {\n            var m = a.length, n = b[0].length;\n            for (var i = 0; i < m; ++i) {\n                for (var j = 0; j < n; ++j) {\n                    b[i][j] = a[i][j];\n                }\n            }\n        }\n\n        // takes a step of stepSize * d from x0, and then project against any constraints.\n        // result is returned in r.\n        // x0: starting positions\n        // r: result positions will be returned here\n        // d: unconstrained descent vector\n        // stepSize: amount to step along d\n        private stepAndProject(x0: number[][], r: number[][], d: number[][], stepSize: number): void {\n            Descent.copy(x0, r);\n            this.takeDescentStep(r[0], d[0], stepSize);\n            if (this.project) this.project[0](x0[0], x0[1], r[0]);\n            this.takeDescentStep(r[1], d[1], stepSize);\n            if (this.project) this.project[1](r[0], x0[1], r[1]);\n\n            // todo: allow projection against constraints in higher dimensions\n            for (var i = 2; i < this.k; i++)\n                this.takeDescentStep(r[i], d[i], stepSize);\n\n            // the following makes locks extra sticky... but hides the result of the projection from the consumer\n            //if (!this.locks.isEmpty()) {\n            //    this.locks.apply((u, p) => {\n            //        for (var i = 0; i < this.k; i++) {\n            //            r[i][u] = p[i];\n            //        }\n            //    });\n            //}\n        }\n\n        private static mApply(m: number, n: number, f: (i: number, j: number) => any) {\n            var i = m; while (i-- > 0) {\n                var j = n; while (j-- > 0) f(i, j);\n            }\n        }\n        private matrixApply(f: (i: number, j: number) => any) {\n            Descent.mApply(this.k, this.n, f);\n        }\n\n        private computeNextPosition(x0: number[][], r: number[][]): void {\n            this.computeDerivatives(x0);\n            var alpha = this.computeStepSize(this.g);\n            this.stepAndProject(x0, r, this.g, alpha);\n/* DEBUG\n            for (var u: number = 0; u < this.n; ++u)\n                for (var i = 0; i < this.k; ++i)\n                    if (isNaN(r[i][u])) debugger;\nDEBUG */\n            if (this.project) {\n                this.matrixApply((i, j) => this.e[i][j] = x0[i][j] - r[i][j]);\n                var beta = this.computeStepSize(this.e);\n                beta = Math.max(0.2, Math.min(beta, 1));\n                this.stepAndProject(x0, r, this.e, beta);\n            }\n        }\n\n        public run(iterations: number): number {\n            var stress = Number.MAX_VALUE, converged = false;\n            while (!converged && iterations-- > 0) {\n                var s = this.rungeKutta();\n                converged = Math.abs(stress / s - 1) < this.threshold;\n                stress = s;\n            }\n            return stress;\n        }\n\n        public rungeKutta(): number {\n            this.computeNextPosition(this.x, this.a);\n            Descent.mid(this.x, this.a, this.ia);\n            this.computeNextPosition(this.ia, this.b);\n            Descent.mid(this.x, this.b, this.ib);\n            this.computeNextPosition(this.ib, this.c);\n            this.computeNextPosition(this.c, this.d);\n            var disp = 0;\n            this.matrixApply((i, j) => {\n                var x = (this.a[i][j] + 2.0 * this.b[i][j] + 2.0 * this.c[i][j] + this.d[i][j]) / 6.0,\n                    d = this.x[i][j] - x;\n                disp += d * d;\n                this.x[i][j] = x;\n            });\n            return disp;\n        }\n\n        private static mid(a: number[][], b: number[][], m: number[][]): void {\n            Descent.mApply(a.length, a[0].length, (i, j) =>\n                m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2.0);\n        }\n\n        public takeDescentStep(x: number[], d: number[], stepSize: number): void {\n            for (var i = 0; i < this.n; ++i) {\n                x[i] = x[i] - stepSize * d[i];\n            }\n        }\n\n        public computeStress(): number {\n            var stress = 0;\n            for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {\n                for (var v = u + 1, n = this.n; v < n; ++v) {\n                    var l = 0;\n                    for (var i = 0; i < this.k; ++i) {\n                        var dx = this.x[i][u] - this.x[i][v];\n                        l += dx * dx;\n                    }\n                    l = Math.sqrt(l);\n                    var d = this.D[u][v];\n                    if (!isFinite(d)) continue;\n                    var rl = d - l;\n                    var d2 = d * d;\n                    stress += rl * rl / d2;\n                }\n            }\n            return stress;\n        }\n    }\n\n    // Linear congruential pseudo random number generator\n    export class PseudoRandom {\n        private a: number = 214013;\n        private c: number = 2531011;\n        private m: number = 2147483648;\n        private range: number = 32767;\n\n        constructor(public seed: number = 1) { }\n\n        // random real between 0 and 1\n        getNext(): number {\n            this.seed = (this.seed * this.a + this.c) % this.m;\n            return (this.seed >> 16) / this.range;\n        }\n\n        // random real between min and max\n        getNextBetween(min: number, max: number) {\n            return min + this.getNext() * (max - min);\n        }\n    }\n","    export class PositionStats {\n        AB: number = 0;\n        AD: number = 0;\n        A2: number = 0;\n\n        constructor(public scale: number) {}\n\n        addVariable(v: Variable): void {\n            var ai = this.scale / v.scale;\n            var bi = v.offset / v.scale;\n            var wi = v.weight;\n            this.AB += wi * ai * bi;\n            this.AD += wi * ai * v.desiredPosition;\n            this.A2 += wi * ai * ai;\n        }\n\n        getPosn(): number {\n            return (this.AD - this.AB) / this.A2;\n        }\n    }\n\n    export class Constraint {\n        lm: number;\n        active: boolean = false;\n        unsatisfiable: boolean = false;\n\n        constructor(public left: Variable, public right: Variable, public gap: number, public equality: boolean = false) {\n            this.left = left;\n            this.right = right;\n            this.gap = gap;\n            this.equality = equality;\n        }\n\n        slack(): number {\n            return this.unsatisfiable ? Number.MAX_VALUE\n                : this.right.scale * this.right.position() - this.gap\n                - this.left.scale * this.left.position();\n        }\n    }\n\n    export class Variable {\n        offset: number = 0;\n        block: Block;\n        cIn: Constraint[];\n        cOut: Constraint[];\n\n        constructor(public desiredPosition: number, public weight: number = 1, public scale: number = 1) {}\n\n        dfdv(): number {\n            return 2.0 * this.weight * (this.position() - this.desiredPosition);\n        }\n\n        position(): number {\n            return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;\n        }\n\n        // visit neighbours by active constraints within the same block\n        visitNeighbours(prev: Variable, f: (c: Constraint, next: Variable) => void ): void {\n            var ff = (c, next) => c.active && prev !== next && f(c, next);\n            this.cOut.forEach(c=> ff(c, c.right));\n            this.cIn.forEach(c=> ff(c, c.left));\n        }\n    }\n\n    export class Block {\n        vars: Variable[] = [];\n        posn: number;\n        ps: PositionStats;\n        blockInd: number;\n\n        constructor(v: Variable) {\n            v.offset = 0;\n            this.ps = new PositionStats(v.scale);\n            this.addVariable(v);\n        }\n\n        private addVariable(v: Variable): void {\n            v.block = this;\n            this.vars.push(v);\n            this.ps.addVariable(v);\n            this.posn = this.ps.getPosn();\n        }\n\n        // move the block where it needs to be to minimize cost\n        updateWeightedPosition(): void {\n            this.ps.AB = this.ps.AD = this.ps.A2 = 0;\n            for (var i = 0, n = this.vars.length; i < n; ++i)\n                this.ps.addVariable(this.vars[i]);\n            this.posn = this.ps.getPosn();\n        }\n\n        private compute_lm(v: Variable, u: Variable, postAction: (c: Constraint)=>void): number {\n            var dfdv = v.dfdv();\n            v.visitNeighbours(u, (c, next) => {\n                var _dfdv = this.compute_lm(next, v, postAction);\n                if (next === c.right) {\n                    dfdv += _dfdv * c.left.scale;\n                    c.lm = _dfdv;\n                } else {\n                    dfdv += _dfdv * c.right.scale;\n                    c.lm = -_dfdv;\n                }\n                postAction(c);\n            });\n            return dfdv / v.scale;\n        }\n\n        private populateSplitBlock(v: Variable, prev: Variable): void {\n            v.visitNeighbours(prev, (c, next) => {\n                next.offset = v.offset + (next === c.right ? c.gap : -c.gap);\n                this.addVariable(next);\n                this.populateSplitBlock(next, v);\n            });\n        }\n\n        // traverse the active constraint tree applying visit to each active constraint\n        traverse(visit: (c: Constraint) => any, acc: any[], v: Variable = this.vars[0], prev: Variable=null) {\n            v.visitNeighbours(prev, (c, next) => {\n                acc.push(visit(c));\n                this.traverse(visit, acc, next, v);\n            });\n        }\n\n        // calculate lagrangian multipliers on constraints and\n        // find the active constraint in this block with the smallest lagrangian.\n        // if the lagrangian is negative, then the constraint is a split candidate.\n        findMinLM(): Constraint {\n            var m: Constraint = null;\n            this.compute_lm(this.vars[0], null, c=> {\n                if (!c.equality && (m === null || c.lm < m.lm)) m = c;\n            });\n            return m;\n        }\n\n        private findMinLMBetween(lv: Variable, rv: Variable): Constraint {\n            this.compute_lm(lv, null, () => {});\n            var m = null;\n            this.findPath(lv, null, rv, (c, next)=> {\n                if (!c.equality && c.right === next && (m === null || c.lm < m.lm)) m = c;\n            });\n            return m;\n        }\n\n        private findPath(v: Variable, prev: Variable, to: Variable, visit: (c: Constraint, next:Variable)=>void): boolean {\n            var endFound = false;\n            v.visitNeighbours(prev, (c, next) => {\n                if (!endFound && (next === to || this.findPath(next, v, to, visit)))\n                {\n                    endFound = true;\n                    visit(c, next);\n                }\n            });\n            return endFound;\n        }\n\n        // Search active constraint tree from u to see if there is a directed path to v.\n        // Returns true if path is found.\n        isActiveDirectedPathBetween(u: Variable, v: Variable) : boolean {\n            if (u === v) return true;\n            var i = u.cOut.length;\n            while(i--) {\n                var c = u.cOut[i];\n                if (c.active && this.isActiveDirectedPathBetween(c.right, v))\n                    return true;\n            }\n            return false;\n        }\n\n        // split the block into two by deactivating the specified constraint\n        static split(c: Constraint): Block[]{\n/* DEBUG\n            console.log(\"split on \" + c);\n            console.assert(c.active, \"attempt to split on inactive constraint\");\nDEBUG */\n            c.active = false;\n            return [Block.createSplitBlock(c.left), Block.createSplitBlock(c.right)];\n        }\n\n        private static createSplitBlock(startVar: Variable): Block {\n            var b = new Block(startVar);\n            b.populateSplitBlock(startVar, null);\n            return b;\n        }\n\n        // find a split point somewhere between the specified variables\n        splitBetween(vl: Variable, vr: Variable): { constraint: Constraint; lb: Block; rb: Block } {\n/* DEBUG\n            console.assert(vl.block === this);\n            console.assert(vr.block === this);\nDEBUG */\n            var c = this.findMinLMBetween(vl, vr);\n            if (c !== null) {\n                var bs = Block.split(c);\n                return { constraint: c, lb: bs[0], rb: bs[1] };\n            }\n            // couldn't find a split point - for example the active path is all equality constraints\n            return null;\n        }\n\n        mergeAcross(b: Block, c: Constraint, dist: number): void {\n            c.active = true;\n            for (var i = 0, n = b.vars.length; i < n; ++i) {\n                var v = b.vars[i];\n                v.offset += dist;\n                this.addVariable(v);\n            }\n            this.posn = this.ps.getPosn();\n        }\n\n        cost(): number {\n            var sum = 0, i = this.vars.length;\n            while (i--) {\n                var v = this.vars[i],\n                    d = v.position() - v.desiredPosition;\n                sum += d * d * v.weight;\n            }\n            return sum;\n        }\n\n/* DEBUG\n        toString(): string {\n            var cs = [];\n            this.traverse(c=> c.toString() + \"\\n\", cs)\n            return \"b\"+this.blockInd + \"@\" + this.posn + \": vars=\" + this.vars.map(v=> v.toString()+\":\"+v.offset) + \";\\n cons=\\n\" + cs;\n        }\nDEBUG */\n    }\n\n    export class Blocks {\n        private list: Block[];\n\n        constructor(public vs: Variable[]) {\n            var n = vs.length;\n            this.list = new Array(n);\n            while (n--) {\n                var b = new Block(vs[n]);\n                this.list[n] = b;\n                b.blockInd = n;\n            }\n        }\n\n        cost(): number {\n            var sum = 0, i = this.list.length;\n            while (i--) sum += this.list[i].cost();\n            return sum;\n        }\n\n        insert(b: Block) {\n/* DEBUG\n            console.assert(!this.contains(b), \"blocks error: tried to reinsert block \" + b.blockInd)\nDEBUG */\n            b.blockInd = this.list.length;\n            this.list.push(b);\n/* DEBUG\n            console.log(\"insert block: \" + b.blockInd);\n            this.contains(b);\nDEBUG */\n        }\n\n        remove(b: Block) {\n/* DEBUG\n            console.log(\"remove block: \" + b.blockInd);\n            console.assert(this.contains(b));\nDEBUG */\n            var last = this.list.length - 1;\n            var swapBlock = this.list[last];\n            this.list.length = last;\n            if (b !== swapBlock) {\n                this.list[b.blockInd] = swapBlock;\n                swapBlock.blockInd = b.blockInd;\n/* DEBUG\n                console.assert(this.contains(swapBlock));\nDEBUG */\n            }\n        }\n\n        // merge the blocks on either side of the specified constraint, by copying the smaller block into the larger\n        // and deleting the smaller.\n        merge(c: Constraint): void {\n            var l = c.left.block, r = c.right.block;\n/* DEBUG\n            console.assert(l!==r, \"attempt to merge within the same block\");\nDEBUG */\n            var dist = c.right.offset - c.left.offset - c.gap;\n            if (l.vars.length < r.vars.length) {\n                r.mergeAcross(l, c, dist);\n                this.remove(l);\n            } else {\n                l.mergeAcross(r, c, -dist);\n                this.remove(r);\n            }\n/* DEBUG\n            console.assert(Math.abs(c.slack()) < 1e-6, \"Error: Constraint should be at equality after merge!\");\n            console.log(\"merged on \" + c);\nDEBUG */\n        }\n\n        forEach(f: (b: Block, i: number) => void ) {\n            this.list.forEach(f);\n        }\n\n        // useful, for example, after variable desired positions change.\n        updateBlockPositions(): void {\n            this.list.forEach(b=> b.updateWeightedPosition());\n        }\n\n        // split each block across its constraint with the minimum lagrangian\n        split(inactive: Constraint[]): void {\n            this.updateBlockPositions();\n            this.list.forEach(b=> {\n                var v = b.findMinLM();\n                if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {\n                    b = v.left.block;\n                    Block.split(v).forEach(nb=>this.insert(nb));\n                    this.remove(b);\n                    inactive.push(v);\n/* DEBUG\n                    console.assert(this.contains(v.left.block));\n                    console.assert(this.contains(v.right.block));\nDEBUG */\n                }\n            });\n        }\n\n/* DEBUG\n        // checks b is in the block, and does a sanity check over list index integrity\n        contains(b: Block): boolean {\n            var result = false;\n            this.list.forEach((bb, i) => {\n                if (bb.blockInd !== i) {\n                    console.error(\"blocks error, blockInd \" + b.blockInd + \" found at \" + i);\n                    return false;\n                }\n                result = result || b === bb;\n            });\n            return result;\n        }\n\n        toString(): string {\n            return this.list.toString();\n        }\nDEBUG */\n    }\n\n    export class Solver {\n        bs: Blocks;\n        inactive: Constraint[];\n\n        static LAGRANGIAN_TOLERANCE = -1e-4;\n        static ZERO_UPPERBOUND = -1e-10;\n\n        constructor(public vs: Variable[], public cs: Constraint[]) {\n            this.vs = vs;\n            vs.forEach(v => {\n                v.cIn = [], v.cOut = [];\n/* DEBUG\n                v.toString = () => \"v\" + vs.indexOf(v);\nDEBUG */\n            });\n            this.cs = cs;\n            cs.forEach(c => {\n                c.left.cOut.push(c);\n                c.right.cIn.push(c);\n/* DEBUG\n                c.toString = () => c.left + \"+\" + c.gap + \"<=\" + c.right + \" slack=\" + c.slack() + \" active=\" + c.active;\nDEBUG */\n            });\n            this.inactive = cs.map(c=> { c.active = false; return c; });\n            this.bs = null;\n        }\n\n        cost(): number {\n            return this.bs.cost();\n        }\n\n        // set starting positions without changing desired positions.\n        // Note: it throws away any previous block structure.\n        setStartingPositions(ps: number[]): void {\n            this.inactive = this.cs.map(c=> { c.active = false; return c; });\n            this.bs = new Blocks(this.vs);\n            this.bs.forEach((b, i) => b.posn = ps[i]);\n        }\n\n        setDesiredPositions(ps: number[]): void {\n            this.vs.forEach((v, i) => v.desiredPosition = ps[i]);\n        }\n\n/* DEBUG\n        private getId(v: Variable): number {\n            return this.vs.indexOf(v);\n        }\n\n        // sanity check of the index integrity of the inactive list\n        checkInactive(): void {\n            var inactiveCount = 0;\n            this.cs.forEach(c=> {\n                var i = this.inactive.indexOf(c);\n                console.assert(!c.active && i >= 0 || c.active && i < 0, \"constraint should be in the inactive list if it is not active: \" + c);\n                if (i >= 0) {\n                    inactiveCount++;\n                } else {\n                    console.assert(c.active, \"inactive constraint not found in inactive list: \" + c);\n                }\n            });\n            console.assert(inactiveCount === this.inactive.length, inactiveCount + \" inactive constraints found, \" + this.inactive.length + \"in inactive list\");\n        }\n        // after every call to satisfy the following should check should pass\n        checkSatisfied(): void {\n            this.cs.forEach(c=>console.assert(c.slack() >= vpsc.Solver.ZERO_UPPERBOUND, \"Error: Unsatisfied constraint! \"+c));\n        }\nDEBUG */\n\n        private mostViolated(): Constraint {\n            var minSlack = Number.MAX_VALUE,\n                v: Constraint = null,\n                l = this.inactive,\n                n = l.length,\n                deletePoint = n;\n            for (var i = 0; i < n; ++i) {\n                var c = l[i];\n                if (c.unsatisfiable) continue;\n                var slack = c.slack();\n                if (c.equality || slack < minSlack) {\n                    minSlack = slack;\n                    v = c;\n                    deletePoint = i;\n                    if (c.equality) break;\n                }\n            }\n            if (deletePoint !== n &&\n                (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality))\n            {\n                l[deletePoint] = l[n - 1];\n                l.length = n - 1;\n            }\n            return v;\n        }\n\n        // satisfy constraints by building block structure over violated constraints\n        // and moving the blocks to their desired positions\n        satisfy(): void {\n            if (this.bs == null) {\n                this.bs = new Blocks(this.vs);\n            }\n/* DEBUG\n            console.log(\"satisfy: \" + this.bs);\nDEBUG */\n            this.bs.split(this.inactive);\n            var v: Constraint = null;\n            while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {\n                var lb = v.left.block, rb = v.right.block;\n/* DEBUG\n                console.log(\"most violated is: \" + v);\n                this.bs.contains(lb);\n                this.bs.contains(rb);\nDEBUG */\n                if (lb !== rb) {\n                    this.bs.merge(v);\n                } else {\n                    if (lb.isActiveDirectedPathBetween(v.right, v.left)) {\n                        // cycle found!\n                        v.unsatisfiable = true;\n                        continue;\n                    }\n                    // constraint is within block, need to split first\n                    var split = lb.splitBetween(v.left, v.right);\n                    if (split !== null) {\n                        this.bs.insert(split.lb);\n                        this.bs.insert(split.rb);\n                        this.bs.remove(lb);\n                        this.inactive.push(split.constraint);\n                    } else {\n/* DEBUG\n                        console.log(\"unsatisfiable constraint found\");\nDEBUG */\n                        v.unsatisfiable = true;\n                        continue;\n                    }\n                    if (v.slack() >= 0) {\n/* DEBUG\n                        console.log(\"violated constraint indirectly satisfied: \" + v);\nDEBUG */\n                        // v was satisfied by the above split!\n                        this.inactive.push(v);\n                    } else {\n/* DEBUG\n                        console.log(\"merge after split:\");\nDEBUG */\n                        this.bs.merge(v);\n                    }\n                }\n/* DEBUG\n                this.bs.contains(v.left.block);\n                this.bs.contains(v.right.block);\n                this.checkInactive();\nDEBUG */\n            }\n/* DEBUG\n            this.checkSatisfied();\nDEBUG */\n        }\n\n        // repeatedly build and split block structure until we converge to an optimal solution\n        solve(): number {\n            this.satisfy();\n            var lastcost = Number.MAX_VALUE, cost = this.bs.cost();\n            while (Math.abs(lastcost - cost) > 0.0001) {\n                this.satisfy();\n                lastcost = cost;\n                cost = this.bs.cost();\n            }\n            return cost;\n        }\n    }\n    /**\n      * Remove overlap between spans while keeping their centers as close as possible to the specified desiredCenters.\n      * Lower and upper bounds will be respected if the spans physically fit between them\n      * (otherwise they'll be moved and their new position returned).\n      * If no upper/lower bound is specified then the bounds of the moved spans will be returned.\n      * returns a new center for each span.\n      */\n    export function removeOverlapInOneDimension(spans: { size: number, desiredCenter: number }[], lowerBound?: number, upperBound?: number)\n        : { newCenters: number[], lowerBound: number, upperBound: number }\n    {\n        const vs: Variable[] = spans.map(s => new Variable(s.desiredCenter));\n        const cs: Constraint[] = [];\n        const n = spans.length;\n        for (var i = 0; i < n - 1; i++) {\n            const left = spans[i], right = spans[i + 1];\n            cs.push(new Constraint(vs[i], vs[i + 1], (left.size + right.size) / 2));\n        }\n        const leftMost = vs[0],\n            rightMost = vs[n - 1],\n            leftMostSize = spans[0].size / 2,\n            rightMostSize = spans[n - 1].size / 2;\n        let vLower: Variable = null, vUpper: Variable = null;\n        if (lowerBound) {\n            vLower = new Variable(lowerBound, leftMost.weight * 1000);\n            vs.push(vLower);\n            cs.push(new Constraint(vLower, leftMost, leftMostSize));\n        }\n        if (upperBound) {\n            vUpper = new Variable(upperBound, rightMost.weight * 1000);\n            vs.push(vUpper);\n            cs.push(new Constraint(rightMost, vUpper, rightMostSize));\n        }\n        var solver = new Solver(vs, cs);\n        solver.solve();\n        return {\n            newCenters: vs.slice(0, spans.length).map(v => v.position()),\n            lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,\n            upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize\n        };\n    }\n","    //Based on js_es:\n    //\n    //https://github.com/vadimg/js_bintrees\n    //\n    //Copyright (C) 2011 by Vadim Graboys\n    //\n    //Permission is hereby granted, free of charge, to any person obtaining a copy\n    //of this software and associated documentation files (the \"Software\"), to deal\n    //in the Software without restriction, including without limitation the rights\n    //to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    //copies of the Software, and to permit persons to whom the Software is\n    //furnished to do so, subject to the following conditions:\n    //\n    //The above copyright notice and this permission notice shall be included in\n    //all copies or substantial portions of the Software.\n    //\n    //THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    //IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    //FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    //AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    //LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    //OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n    //THE SOFTWARE.\n    export class TreeBase {\n        _root;\n        size;\n        _comparator;\n        // removes all nodes from the tree\n        clear() {\n            this._root = null;\n            this.size = 0;\n        };\n\n        // returns node data if found, null otherwise\n        find(data) {\n            var res = this._root;\n\n            while (res !== null) {\n                var c = this._comparator(data, res.data);\n                if (c === 0) {\n                    return res.data;\n                }\n                else {\n                    res = res.get_child(c > 0);\n                }\n            }\n\n            return null;\n        };\n\n        // returns iterator to node if found, null otherwise\n        findIter = function (data) {\n            var res = this._root;\n            var iter = this.iterator();\n\n            while (res !== null) {\n                var c = this._comparator(data, res.data);\n                if (c === 0) {\n                    iter._cursor = res;\n                    return iter;\n                }\n                else {\n                    iter._ancestors.push(res);\n                    res = res.get_child(c > 0);\n                }\n            }\n\n            return null;\n        };\n\n        // Returns an interator to the tree node immediately before (or at) the element\n        lowerBound(data) {\n            return this._bound(data, this._comparator);\n        };\n\n        // Returns an interator to the tree node immediately after (or at) the element\n        upperBound(data) {\n            var cmp = this._comparator;\n\n            function reverse_cmp(a, b) {\n                return cmp(b, a);\n            }\n\n            return this._bound(data, reverse_cmp);\n        };\n\n        // returns null if tree is empty\n        min() {\n            var res = this._root;\n            if (res === null) {\n                return null;\n            }\n\n            while (res.left !== null) {\n                res = res.left;\n            }\n\n            return res.data;\n        };\n\n        // returns null if tree is empty\n        max() {\n            var res = this._root;\n            if (res === null) {\n                return null;\n            }\n\n            while (res.right !== null) {\n                res = res.right;\n            }\n\n            return res.data;\n        };\n\n        // returns a null iterator\n        // call next() or prev() to point to an element\n        iterator(): Iterator {\n            return new Iterator(this);\n        };\n\n        // calls cb on each node's data, in order\n        each(cb) {\n            var it = this.iterator(), data;\n            while ((data = it.next()) !== null) {\n                cb(data);\n            }\n        };\n\n        // calls cb on each node's data, in reverse order\n        reach(cb) {\n            var it = this.iterator(), data;\n            while ((data = it.prev()) !== null) {\n                cb(data);\n            }\n        };\n\n        // used for lowerBound and upperBound\n        _bound(data, cmp) {\n            var cur = this._root;\n            var iter = this.iterator();\n\n            while (cur !== null) {\n                var c = this._comparator(data, cur.data);\n                if (c === 0) {\n                    iter._cursor = cur;\n                    return iter;\n                }\n                iter._ancestors.push(cur);\n                cur = cur.get_child(c > 0);\n            }\n\n            for (var i = iter._ancestors.length - 1; i >= 0; --i) {\n                cur = iter._ancestors[i];\n                if (cmp(data, cur.data) > 0) {\n                    iter._cursor = cur;\n                    iter._ancestors.length = i;\n                    return iter;\n                }\n            }\n\n            iter._ancestors.length = 0;\n            return iter;\n        };\n    }\n    export class Iterator {\n        _tree;\n        _ancestors;\n        _cursor;\n        constructor(tree) {\n            this._tree = tree;\n            this._ancestors = [];\n            this._cursor = null;\n        }\n\n        data() {\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        // if null-iterator, returns first node\n        // otherwise, returns next node\n        next() {\n            if (this._cursor === null) {\n                var root = this._tree._root;\n                if (root !== null) {\n                    this._minNode(root);\n                }\n            }\n            else {\n                if (this._cursor.right === null) {\n                    // no greater node in subtree, go up to parent\n                    // if coming from a right child, continue up the stack\n                    var save;\n                    do {\n                        save = this._cursor;\n                        if (this._ancestors.length) {\n                            this._cursor = this._ancestors.pop();\n                        }\n                        else {\n                            this._cursor = null;\n                            break;\n                        }\n                    } while (this._cursor.right === save);\n                }\n                else {\n                    // get the next node from the subtree\n                    this._ancestors.push(this._cursor);\n                    this._minNode(this._cursor.right);\n                }\n            }\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        // if null-iterator, returns last node\n        // otherwise, returns previous node\n        prev() {\n            if (this._cursor === null) {\n                var root = this._tree._root;\n                if (root !== null) {\n                    this._maxNode(root);\n                }\n            }\n            else {\n                if (this._cursor.left === null) {\n                    var save;\n                    do {\n                        save = this._cursor;\n                        if (this._ancestors.length) {\n                            this._cursor = this._ancestors.pop();\n                        }\n                        else {\n                            this._cursor = null;\n                            break;\n                        }\n                    } while (this._cursor.left === save);\n                }\n                else {\n                    this._ancestors.push(this._cursor);\n                    this._maxNode(this._cursor.left);\n                }\n            }\n            return this._cursor !== null ? this._cursor.data : null;\n        };\n\n        _minNode(start) {\n            while (start.left !== null) {\n                this._ancestors.push(start);\n                start = start.left;\n            }\n            this._cursor = start;\n        };\n\n        _maxNode(start) {\n            while (start.right !== null) {\n                this._ancestors.push(start);\n                start = start.right;\n            }\n            this._cursor = start;\n        };\n    }\n\n    class Node {\n        data;\n        left;\n        right;\n        red;\n        constructor(data) {\n            this.data = data;\n            this.left = null;\n            this.right = null;\n            this.red = true;\n        }\n\n        get_child(dir) {\n            return dir ? this.right : this.left;\n        };\n\n        set_child(dir, val) {\n            if (dir) {\n                this.right = val;\n            }\n            else {\n                this.left = val;\n            }\n        };\n    }\n\n    export class RBTree<T> extends TreeBase {\n\n        _root;\n        _comparator;\n        size;\n        constructor(comparator: (a: T, b: T) => number) {\n            super();\n            this._root = null;\n            this._comparator = comparator;\n            this.size = 0;\n        }\n\n        // returns true if inserted, false if duplicate\n        insert(data) {\n            var ret = false;\n\n            if (this._root === null) {\n                // empty tree\n                this._root = new Node(data);\n                ret = true;\n                this.size++;\n            }\n            else {\n                var head = new Node(undefined); // fake tree root\n\n                var dir = false;\n                var last = false;\n\n                // setup\n                var gp = null; // grandparent\n                var ggp = head; // grand-grand-parent\n                var p = null; // parent\n                var node = this._root;\n                ggp.right = this._root;\n\n                // search down\n                while (true) {\n                    if (node === null) {\n                        // insert new node at the bottom\n                        node = new Node(data);\n                        p.set_child(dir, node);\n                        ret = true;\n                        this.size++;\n                    }\n                    else if (RBTree.is_red(node.left) && RBTree.is_red(node.right)) {\n                        // color flip\n                        node.red = true;\n                        node.left.red = false;\n                        node.right.red = false;\n                    }\n\n                    // fix red violation\n                    if (RBTree.is_red(node) && RBTree.is_red(p)) {\n                        var dir2 = ggp.right === gp;\n\n                        if (node === p.get_child(last)) {\n                            ggp.set_child(dir2, RBTree.single_rotate(gp, !last));\n                        }\n                        else {\n                            ggp.set_child(dir2, RBTree.double_rotate(gp, !last));\n                        }\n                    }\n\n                    var cmp = this._comparator(node.data, data);\n\n                    // stop if found\n                    if (cmp === 0) {\n                        break;\n                    }\n\n                    last = dir;\n                    dir = cmp < 0;\n\n                    // update helpers\n                    if (gp !== null) {\n                        ggp = gp;\n                    }\n                    gp = p;\n                    p = node;\n                    node = node.get_child(dir);\n                }\n\n                // update root\n                this._root = head.right;\n            }\n\n            // make root black\n            this._root.red = false;\n\n            return ret;\n        };\n\n        // returns true if removed, false if not found\n        remove(data) {\n            if (this._root === null) {\n                return false;\n            }\n\n            var head = new Node(undefined); // fake tree root\n            var node = head;\n            node.right = this._root;\n            var p = null; // parent\n            var gp = null; // grand parent\n            var found = null; // found item\n            var dir = true;\n\n            while (node.get_child(dir) !== null) {\n                var last = dir;\n\n                // update helpers\n                gp = p;\n                p = node;\n                node = node.get_child(dir);\n\n                var cmp = this._comparator(data, node.data);\n\n                dir = cmp > 0;\n\n                // save found node\n                if (cmp === 0) {\n                    found = node;\n                }\n\n                // push the red node down\n                if (!RBTree.is_red(node) && !RBTree.is_red(node.get_child(dir))) {\n                    if (RBTree.is_red(node.get_child(!dir))) {\n                        var sr = RBTree.single_rotate(node, dir);\n                        p.set_child(last, sr);\n                        p = sr;\n                    }\n                    else if (!RBTree.is_red(node.get_child(!dir))) {\n                        var sibling = p.get_child(!last);\n                        if (sibling !== null) {\n                            if (!RBTree.is_red(sibling.get_child(!last)) && !RBTree.is_red(sibling.get_child(last))) {\n                                // color flip\n                                p.red = false;\n                                sibling.red = true;\n                                node.red = true;\n                            }\n                            else {\n                                var dir2 = gp.right === p;\n\n                                if (RBTree.is_red(sibling.get_child(last))) {\n                                    gp.set_child(dir2, RBTree.double_rotate(p, last));\n                                }\n                                else if (RBTree.is_red(sibling.get_child(!last))) {\n                                    gp.set_child(dir2, RBTree.single_rotate(p, last));\n                                }\n\n                                // ensure correct coloring\n                                var gpc = gp.get_child(dir2);\n                                gpc.red = true;\n                                node.red = true;\n                                gpc.left.red = false;\n                                gpc.right.red = false;\n                            }\n                        }\n                    }\n                }\n            }\n\n            // replace and remove if found\n            if (found !== null) {\n                found.data = node.data;\n                p.set_child(p.right === node, node.get_child(node.left === null));\n                this.size--;\n            }\n\n            // update root and make it black\n            this._root = head.right;\n            if (this._root !== null) {\n                this._root.red = false;\n            }\n\n            return found !== null;\n        };\n\n        static is_red(node) {\n            return node !== null && node.red;\n        }\n\n        static single_rotate(root, dir) {\n            var save = root.get_child(!dir);\n\n            root.set_child(!dir, save.get_child(dir));\n            save.set_child(dir, root);\n\n            root.red = true;\n            save.red = false;\n\n            return save;\n        }\n\n        static double_rotate(root, dir) {\n            root.set_child(!dir, RBTree.single_rotate(root.get_child(!dir), !dir));\n            return RBTree.single_rotate(root, dir);\n        }\n    }\n","import {Constraint, Variable, Solver} from './vpsc'\nimport {RBTree} from './rbtree'\nimport {Point} from './geom'\n\n    export interface Leaf {\n        bounds: Rectangle;\n        variable: Variable;\n    }\n\n    export interface ProjectionGroup {\n        bounds: Rectangle;\n        padding: number;\n        stiffness: number;\n        leaves: Leaf[];\n        groups: ProjectionGroup[];\n        minVar: Variable;\n        maxVar: Variable;\n    }\n\n    export function computeGroupBounds(g: ProjectionGroup): Rectangle {\n        g.bounds = typeof g.leaves !== \"undefined\" ?\n            g.leaves.reduce((r: Rectangle, c) => c.bounds.union(r), Rectangle.empty()) :\n            Rectangle.empty();\n        if (typeof g.groups !== \"undefined\")\n            g.bounds = <Rectangle>g.groups.reduce((r: Rectangle, c) => computeGroupBounds(c).union(r), g.bounds);\n        g.bounds = g.bounds.inflate(g.padding);\n        return g.bounds;\n    }\n\n    export class Rectangle {\n        constructor(\n            public x: number,\n            public X: number,\n            public y: number,\n            public Y: number) { }\n\n        static empty(): Rectangle { return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY); }\n\n        cx(): number { return (this.x + this.X) / 2; }\n\n        cy(): number { return (this.y + this.Y) / 2; }\n\n        overlapX(r: Rectangle): number {\n            var ux = this.cx(), vx = r.cx();\n            if (ux <= vx && r.x < this.X) return this.X - r.x;\n            if (vx <= ux && this.x < r.X) return r.X - this.x;\n            return 0;\n        }\n\n        overlapY(r: Rectangle): number {\n            var uy = this.cy(), vy = r.cy();\n            if (uy <= vy && r.y < this.Y) return this.Y - r.y;\n            if (vy <= uy && this.y < r.Y) return r.Y - this.y;\n            return 0;\n        }\n\n        setXCentre(cx: number): void {\n            var dx = cx - this.cx();\n            this.x += dx;\n            this.X += dx;\n        }\n\n        setYCentre(cy: number): void {\n            var dy = cy - this.cy();\n            this.y += dy;\n            this.Y += dy;\n        }\n\n        width(): number {\n            return this.X - this.x;\n        }\n\n        height(): number {\n            return this.Y - this.y;\n        }\n\n        union(r: Rectangle): Rectangle {\n            return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));\n        }\n\n        /**\n         * return any intersection points between the given line and the sides of this rectangle\n         * @method lineIntersection\n         * @param x1 number first x coord of line\n         * @param y1 number first y coord of line\n         * @param x2 number second x coord of line\n         * @param y2 number second y coord of line\n         * @return any intersection points found\n         */\n        lineIntersections(x1: number, y1: number, x2: number, y2: number): Array<Point> {\n            var sides = [[this.x, this.y, this.X, this.y],\n                    [this.X, this.y, this.X, this.Y],\n                    [this.X, this.Y, this.x, this.Y],\n                [this.x, this.Y, this.x, this.y]];\n            var intersections = [];\n            for (var i = 0; i < 4; ++i) {\n                var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);\n                if (r !== null) intersections.push({ x: r.x, y: r.y });\n            }\n            return intersections;\n        }\n\n        /**\n         * return any intersection points between a line extending from the centre of this rectangle to the given point,\n         *  and the sides of this rectangle\n         * @method lineIntersection\n         * @param x2 number second x coord of line\n         * @param y2 number second y coord of line\n         * @return any intersection points found\n         */\n        rayIntersection(x2: number, y2: number): Point {\n            var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);\n            return ints.length > 0 ? ints[0] : null;\n        }\n\n        vertices(): Point[] {\n            return [\n                { x: this.x, y: this.y },\n                { x: this.X, y: this.y },\n                { x: this.X, y: this.Y },\n                { x: this.x, y: this.Y }];\n        }\n\n        static lineIntersection(\n            x1: number, y1: number,\n            x2: number, y2: number,\n            x3: number, y3: number,\n            x4: number, y4: number): Point {\n            var dx12 = x2 - x1, dx34 = x4 - x3,\n                dy12 = y2 - y1, dy34 = y4 - y3,\n                denominator = dy34 * dx12 - dx34 * dy12;\n            if (denominator == 0) return null;\n            var dx31 = x1 - x3, dy31 = y1 - y3,\n                numa = dx34 * dy31 - dy34 * dx31,\n                a = numa / denominator,\n                numb = dx12 * dy31 - dy12 * dx31,\n                b = numb / denominator;\n            if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {\n                return {\n                    x: x1 + a * dx12,\n                    y: y1 + a * dy12\n                };\n            }\n            return null;\n        }\n\n        inflate(pad: number): Rectangle {\n            return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);\n        }\n    }\n\n    /**\n     * Returns the endpoints of a line that connects the centre of two rectangles.\n     * @param {Rectangle} [source] The source Rectangle.\n     * @param {Rectangle} [target] The target Rectangle.\n     * @param {number} [ah] The size of the arrow head, a distance to shorten the\n     *                      line by.\n     * @return An object with three point properties, the intersection with the\n     *         source rectangle (sourceIntersection), the intersection with then\n     *         target rectangle (targetIntersection), and the point an arrow\n     *         head of the specified size would need to start (arrowStart).\n     */\n    export function makeEdgeBetween(source: Rectangle, target: Rectangle, ah: number)\n        : { sourceIntersection: Point; targetIntersection: Point; arrowStart: Point } {\n        const si = source.rayIntersection(target.cx(), target.cy()) || { x: source.cx(), y: source.cy() },\n            ti = target.rayIntersection(source.cx(), source.cy()) || { x: target.cx(), y: target.cy() },\n            dx = ti.x - si.x,\n            dy = ti.y - si.y,\n            l = Math.sqrt(dx * dx + dy * dy), al = l - ah;\n        return {\n            sourceIntersection: si,\n            targetIntersection: ti,\n            arrowStart: { x: si.x + al * dx / l, y: si.y + al * dy / l }\n        }\n    }\n\n    /**\n     * Returns the intersection of a line from the given point to the centre\n     * of the target rectangle where it intersects the rectanngle.\n     * @param [source] The source point.\n     * @param {Rectangle} [target] The target Rectangle.\n     * @param {number} [ah] The size of the arrow head, a distance to shorten the\n     *                      line by.\n     * @return The point an arrow head of the specified size would need to start.\n     */\n    export function makeEdgeTo(s: { x: number; y: number }, target: Rectangle, ah: number): Point {\n        var ti = target.rayIntersection(s.x, s.y);\n        if (!ti) ti = { x: target.cx(), y: target.cy() };\n        var dx = ti.x - s.x,\n            dy = ti.y - s.y,\n            l = Math.sqrt(dx * dx + dy * dy);\n        return { x: ti.x - ah * dx / l, y: ti.y - ah * dy / l };\n    }\n\n    class Node {\n        prev: RBTree<Node>;\n        next: RBTree<Node>;\n\n        constructor(public v: Variable, public r: Rectangle, public pos: number) {\n            this.prev = makeRBTree();\n            this.next = makeRBTree();\n        }\n    }\n\n    class Event {\n        constructor(public isOpen: boolean, public v: Node, public pos: number) {}\n    }\n\n    function compareEvents(a: Event, b: Event): number {\n        if (a.pos > b.pos) {\n            return 1;\n        }\n        if (a.pos < b.pos) {\n            return -1;\n        }\n        if (a.isOpen) {\n            // open must come before close\n            return -1;\n        }\n        if (b.isOpen) {\n            // open must come before close\n            return 1;\n        }\n        return 0;\n    }\n\n    function makeRBTree(): RBTree<Node> {\n        return new RBTree<Node>((a, b) => a.pos - b.pos);\n    }\n\n    interface RectAccessors {\n        getCentre: (r: Rectangle) => number;\n        getOpen: (r: Rectangle) => number;\n        getClose: (r: Rectangle) => number;\n        getSize: (r: Rectangle) => number;\n        makeRect: (open: number, close: number, center: number, size: number) => Rectangle;\n        findNeighbours: (v: Node, scanline: RBTree<Node>) => void;\n    }\n\n    var xRect: RectAccessors = {\n        getCentre: r=> r.cx(),\n        getOpen: r=> r.y,\n        getClose: r=> r.Y,\n        getSize: r=> r.width(),\n        makeRect: (open, close, center, size) => new Rectangle(center - size / 2, center + size / 2, open, close) ,\n        findNeighbours: findXNeighbours\n    };\n\n    var yRect: RectAccessors = {\n        getCentre: r=> r.cy(),\n        getOpen: r=> r.x,\n        getClose: r=> r.X,\n        getSize: r=> r.height(),\n        makeRect: (open, close, center, size) => new Rectangle(open, close, center - size / 2, center + size / 2),\n        findNeighbours: findYNeighbours\n    };\n\n    function generateGroupConstraints(root: ProjectionGroup, f: RectAccessors, minSep: number, isContained: boolean = false): Constraint[]\n    {\n        var padding = root.padding,\n            gn = typeof root.groups !== 'undefined' ? root.groups.length : 0,\n            ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0,\n            childConstraints: Constraint[] = !gn ? []\n            : root.groups.reduce((ccs: Constraint[], g) => ccs.concat(generateGroupConstraints(g, f, minSep, true)), []),\n            n = (isContained ? 2 : 0) + ln + gn,\n            vs: Variable[] = new Array(n),\n            rs: Rectangle[] = new Array(n),\n            i = 0,\n            add = (r, v) => { rs[i] = r; vs[i++] = v };\n        if (isContained) {\n            // if this group is contained by another, then we add two dummy vars and rectangles for the borders\n            var b: Rectangle = root.bounds,\n                c = f.getCentre(b), s = f.getSize(b) / 2,\n                open = f.getOpen(b), close = f.getClose(b),\n                min = c - s + padding / 2, max = c + s - padding / 2;\n            root.minVar.desiredPosition = min;\n            add(f.makeRect(open, close, min, padding), root.minVar);\n            root.maxVar.desiredPosition = max;\n            add(f.makeRect(open, close, max, padding), root.maxVar);\n        }\n        if (ln) root.leaves.forEach(l => add(l.bounds, l.variable));\n        if (gn) root.groups.forEach(g => {\n            var b: Rectangle = g.bounds;\n            add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);\n        });\n        var cs = generateConstraints(rs, vs, f, minSep);\n        if (gn) {\n            vs.forEach(v => { v.cOut = [], v.cIn = [] });\n            cs.forEach(c => { c.left.cOut.push(c), c.right.cIn.push(c) });\n            root.groups.forEach(g => {\n                var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;\n                g.minVar.cIn.forEach(c => c.gap += gapAdjustment);\n                g.minVar.cOut.forEach(c => { c.left = g.maxVar; c.gap += gapAdjustment; });\n            });\n        }\n        return childConstraints.concat(cs);\n    }\n\n    function generateConstraints(rs: Rectangle[], vars: Variable[],\n        rect: RectAccessors, minSep: number): Constraint[]\n    {\n        var i, n = rs.length;\n        var N = 2 * n;\n        console.assert(vars.length >= n);\n        var events = new Array<Event>(N);\n        for (i = 0; i < n; ++i) {\n            var r = rs[i];\n            var v = new Node(vars[i], r, rect.getCentre(r));\n            events[i] = new Event(true, v, rect.getOpen(r));\n            events[i + n] = new Event(false, v, rect.getClose(r));\n        }\n        events.sort(compareEvents);\n        var cs = new Array<Constraint>();\n        var scanline = makeRBTree();\n        for (i = 0; i < N; ++i) {\n            var e = events[i];\n            var v = e.v;\n            if (e.isOpen) {\n                scanline.insert(v);\n                rect.findNeighbours(v, scanline);\n            } else {\n                // close event\n                scanline.remove(v);\n                var makeConstraint = (l, r) => {\n                    var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;\n                    cs.push(new Constraint(l.v, r.v, sep));\n                };\n                var visitNeighbours = (forward, reverse, mkcon) => {\n                    var u, it = v[forward].iterator();\n                    while ((u = it[forward]()) !== null) {\n                        mkcon(u, v);\n                        u[reverse].remove(v);\n                    }\n                };\n                visitNeighbours(\"prev\", \"next\", (u, v) => makeConstraint(u, v));\n                visitNeighbours(\"next\", \"prev\", (u, v) => makeConstraint(v, u));\n            }\n        }\n        console.assert(scanline.size === 0);\n        return cs;\n    }\n\n    function findXNeighbours(v: Node, scanline: RBTree<Node>): void {\n        var f = (forward, reverse) => {\n            var it = scanline.findIter(v);\n            var u;\n            while ((u = it[forward]()) !== null) {\n                var uovervX = u.r.overlapX(v.r);\n                if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {\n                    v[forward].insert(u);\n                    u[reverse].insert(v);\n                }\n                if (uovervX <= 0) {\n                    break;\n                }\n            }\n        }\n        f(\"next\", \"prev\");\n        f(\"prev\", \"next\");\n    }\n\n    function findYNeighbours(v: Node, scanline: RBTree<Node>): void {\n        var f = (forward, reverse) => {\n            var u = scanline.findIter(v)[forward]();\n            if (u !== null && u.r.overlapX(v.r) > 0) {\n                v[forward].insert(u);\n                u[reverse].insert(v);\n            }\n        }\n        f(\"next\", \"prev\");\n        f(\"prev\", \"next\");\n    }\n\n    export function generateXConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {\n        return generateConstraints(rs, vars, xRect, 1e-6);\n    }\n\n    export function generateYConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {\n        return generateConstraints(rs, vars, yRect, 1e-6);\n    }\n\n    export function generateXGroupConstraints(root: ProjectionGroup): Constraint[] {\n        return generateGroupConstraints(root, xRect, 1e-6);\n    }\n\n    export function generateYGroupConstraints(root: ProjectionGroup): Constraint[] {\n        return generateGroupConstraints(root, yRect, 1e-6);\n    }\n\n    export function removeOverlaps(rs: Rectangle[]): void {\n        var vs = rs.map(r => new Variable(r.cx()));\n        var cs = generateXConstraints(rs, vs);\n        var solver = new Solver(vs, cs);\n        solver.solve();\n        vs.forEach((v, i) => rs[i].setXCentre(v.position()));\n        vs = rs.map(r=> new Variable(r.cy()));\n        cs = generateYConstraints(rs, vs);\n        solver = new Solver(vs, cs);\n        solver.solve();\n        vs.forEach((v, i) => rs[i].setYCentre(v.position()));\n    }\n\n    export interface GraphNode extends Leaf {\n        fixed: boolean;\n        fixedWeight?: number;\n        width: number;\n        height: number;\n        x: number;\n        y: number;\n        px: number;\n        py: number;\n    }\n\n    export class IndexedVariable extends Variable {\n        constructor(public index: number, w: number) {\n            super(0, w);\n        }\n    }\n\n    export class Projection {\n        private xConstraints: Constraint[];\n        private yConstraints: Constraint[];\n        private variables: Variable[];\n\n        constructor(private nodes: GraphNode[],\n            private groups: ProjectionGroup[],\n            private rootGroup: ProjectionGroup = null,\n            constraints: any[]= null,\n            private avoidOverlaps: boolean = false)\n        {\n            this.variables = nodes.map((v, i) => {\n                return v.variable = new IndexedVariable(i, 1);\n            });\n\n            if (constraints) this.createConstraints(constraints);\n\n            if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {\n                nodes.forEach(v => {\n\t\t\t\t\tif (!v.width || !v.height)\n\t\t\t\t\t{\n\t\t\t\t\t\t//If undefined, default to nothing\n\t\t\t\t\t\tv.bounds = new Rectangle(v.x, v.x, v.y, v.y);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n                    var w2 = v.width / 2, h2 = v.height / 2;\n                    v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);\n                });\n                computeGroupBounds(rootGroup);\n                var i = nodes.length;\n                groups.forEach(g => {\n                    this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n                    this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== \"undefined\" ? g.stiffness : 0.01);\n                });\n            }\n        }\n\n\n        private createSeparation(c: any) : Constraint {\n            return new Constraint(\n                this.nodes[c.left].variable,\n                this.nodes[c.right].variable,\n                c.gap,\n                typeof c.equality !== \"undefined\" ? c.equality : false);\n        }\n\n        // simple satisfaction of alignment constraints to ensure initial feasibility\n        private makeFeasible(c: any) {\n            if (!this.avoidOverlaps) return;\n            // sort nodes in constraint by position (along \"guideline\")\n            var axis = 'x', dim = 'width';\n            if (c.axis === 'x') axis = 'y', dim = 'height';\n            var vs: GraphNode[] = c.offsets.map(o => this.nodes[o.node]).sort((a, b) => a[axis] - b[axis]);\n            var p: GraphNode = null;\n            vs.forEach(v => {\n                // if two nodes overlap then shove the second one along\n                if (p) {\n                    let nextPos = p[axis] + p[dim];\n                    if (nextPos > v[axis]) {\n                        v[axis] = nextPos;\n                    }\n                }\n                p = v;\n            });\n        }\n\n        private createAlignment(c: any) {\n            var u = this.nodes[c.offsets[0].node].variable;\n            this.makeFeasible(c);\n            var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;\n            c.offsets.slice(1).forEach(o => {\n                var v = this.nodes[o.node].variable;\n                cs.push(new Constraint(u, v, o.offset, true));\n            });\n        }\n\n        private createConstraints(constraints: any[]) {\n            var isSep = c => typeof c.type === 'undefined' || c.type === 'separation';\n            this.xConstraints = constraints\n                .filter(c => c.axis === \"x\" && isSep(c))\n                .map(c => this.createSeparation(c));\n            this.yConstraints = constraints\n                .filter(c => c.axis === \"y\" && isSep(c))\n                .map(c => this.createSeparation(c));\n            constraints\n                .filter(c => c.type === 'alignment')\n                .forEach(c => this.createAlignment(c));\n        }\n\n        private setupVariablesAndBounds(x0: number[], y0: number[], desired: number[], getDesired: (v: GraphNode) => number) {\n            this.nodes.forEach((v, i) => {\n                if (v.fixed) {\n                    v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;\n                    desired[i] = getDesired(v);\n                } else {\n                    v.variable.weight = 1;\n                }\n                var w = (v.width || 0) / 2, h = (v.height || 0) / 2;\n                var ix = x0[i], iy = y0[i];\n                v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);\n            });\n        }\n\n        xProject(x0: number[], y0: number[], x: number[]) {\n            if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints)) return;\n            this.project(x0, y0, x0, x, v=> v.px, this.xConstraints, generateXGroupConstraints,\n                v => v.bounds.setXCentre(x[(<IndexedVariable>v.variable).index] = v.variable.position()),\n                g => {\n                    var xmin = x[(<IndexedVariable>g.minVar).index] = g.minVar.position();\n                    var xmax = x[(<IndexedVariable>g.maxVar).index] = g.maxVar.position();\n                    var p2 = g.padding / 2;\n                    g.bounds.x = xmin - p2;\n                    g.bounds.X = xmax + p2;\n                });\n        }\n\n        yProject(x0: number[], y0: number[], y: number[]) {\n            if (!this.rootGroup && !this.yConstraints) return;\n            this.project(x0, y0, y0, y, v=> v.py, this.yConstraints, generateYGroupConstraints,\n                v => v.bounds.setYCentre(y[(<IndexedVariable>v.variable).index] = v.variable.position()),\n                g => {\n                    var ymin = y[(<IndexedVariable>g.minVar).index] = g.minVar.position();\n                    var ymax = y[(<IndexedVariable>g.maxVar).index] = g.maxVar.position();\n                    var p2 = g.padding / 2;\n                    g.bounds.y = ymin - p2;;\n                    g.bounds.Y = ymax + p2;\n                });\n        }\n\n        projectFunctions(): { (x0: number[], y0: number[], r: number[]): void }[]{\n            return [\n                (x0, y0, x) => this.xProject(x0, y0, x),\n                (x0, y0, y) => this.yProject(x0, y0, y)\n            ];\n        }\n\n        private project(x0: number[], y0: number[], start: number[], desired: number[],\n            getDesired: (v: GraphNode) => number,\n            cs: Constraint[],\n            generateConstraints: (g: ProjectionGroup) => Constraint[],\n            updateNodeBounds: (v: GraphNode) => any,\n            updateGroupBounds: (g: ProjectionGroup) => any)\n        {\n            this.setupVariablesAndBounds(x0, y0, desired, getDesired);\n            if (this.rootGroup && this.avoidOverlaps) {\n                computeGroupBounds(this.rootGroup);\n                cs = cs.concat(generateConstraints(this.rootGroup));\n            }\n            this.solve(this.variables, cs, start, desired);\n            this.nodes.forEach(updateNodeBounds);\n            if (this.rootGroup && this.avoidOverlaps) {\n                this.groups.forEach(updateGroupBounds);\n                computeGroupBounds(this.rootGroup);\n            }\n        }\n\n        private solve(vs: Variable[], cs: Constraint[], starting: number[], desired: number[]) {\n            var solver = new Solver(vs, cs);\n            solver.setStartingPositions(starting);\n            solver.setDesiredPositions(desired);\n            solver.solve();\n        }\n    }\n","\nexport class PairingHeap<T> {\n    private subheaps : PairingHeap<T>[];\n    // from: https://gist.github.com/nervoussystem\n    //{elem:object, subheaps:[array of heaps]}\n    constructor(public elem: T) {\n        this.subheaps = [];\n    }\n\n    public toString(selector) : string {\n        var str = \"\", needComma = false;\n        for (var i = 0; i < this.subheaps.length; ++i) {\n            var subheap: PairingHeap<T> = this.subheaps[i];\n            if (!subheap.elem) {\n                needComma = false;\n                continue;\n            }\n            if (needComma) {\n                str = str + \",\";\n            }\n            str = str + subheap.toString(selector);\n            needComma = true;\n        }\n        if (str !== \"\") {\n            str = \"(\" + str + \")\";\n        }\n        return (this.elem ? selector(this.elem) : \"\") + str;\n    }\n\n    public forEach(f) {\n        if (!this.empty()) {\n            f(this.elem, this);\n            this.subheaps.forEach(s => s.forEach(f));\n        }\n    }\n\n    public count(): number {\n        return this.empty() ? 0 : 1 + this.subheaps.reduce((n: number, h: PairingHeap<T>) => {\n            return n + h.count();\n        }, 0);\n    }\n\n    public min() : T {\n        return this.elem;\n    }\n\n    public empty() : boolean {\n        return this.elem == null;\n    }\n\n    public contains(h: PairingHeap<T>): boolean {\n        if (this === h) return true;\n        for (var i = 0; i < this.subheaps.length; i++) {\n            if (this.subheaps[i].contains(h)) return true;\n        }\n        return false;\n    }\n\n    public isHeap(lessThan: (a: T, b: T) => boolean): boolean {\n        return this.subheaps.every(h=> lessThan(this.elem, h.elem) && h.isHeap(lessThan));\n    }\n\n    public insert(obj : T, lessThan) : PairingHeap<T> {\n        return this.merge(new PairingHeap<T>(obj), lessThan);\n    }\n\n    public merge(heap2: PairingHeap<T>, lessThan): PairingHeap<T> {\n        if (this.empty()) return heap2;\n        else if (heap2.empty()) return this;\n        else if (lessThan(this.elem, heap2.elem)) {\n            this.subheaps.push(heap2);\n            return this;\n        } else {\n            heap2.subheaps.push(this);\n            return heap2;\n        }\n    }\n\n    public removeMin(lessThan: (a: T, b: T) => boolean): PairingHeap<T> {\n        if (this.empty()) return null;\n        else return this.mergePairs(lessThan);\n    }\n\n    public mergePairs(lessThan: (a: T, b: T) => boolean) : PairingHeap<T> {\n        if (this.subheaps.length == 0) return new PairingHeap<T>(null);\n        else if (this.subheaps.length == 1) { return this.subheaps[0]; }\n        else {\n            var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);\n            var remaining = this.mergePairs(lessThan);\n            return firstPair.merge(remaining, lessThan);\n        }\n    }\n    public decreaseKey(subheap: PairingHeap<T>, newValue: T, setHeapNode: (e: T, h: PairingHeap<T>)=>void, lessThan: (a: T, b: T) => boolean): PairingHeap<T> {\n        var newHeap = subheap.removeMin(lessThan);\n        //reassign subheap values to preserve tree\n        subheap.elem = newHeap.elem;\n        subheap.subheaps = newHeap.subheaps;\n        if (setHeapNode !== null && newHeap.elem !== null) {\n            setHeapNode(subheap.elem, subheap);\n        }\n        var pairingNode = new PairingHeap(newValue);\n        if (setHeapNode !== null) {\n            setHeapNode(newValue, pairingNode);\n        }\n        return this.merge(pairingNode, lessThan);\n    }\n}\n\n/**\n * @class PriorityQueue a min priority queue backed by a pairing heap\n */\nexport class PriorityQueue<T> {\n    private root : PairingHeap<T>;\n    constructor(private lessThan: (a: T, b: T) => boolean) { }\n    /**\n     * @method top\n     * @return the top element (the min element as defined by lessThan)\n     */\n    public top() : T {\n        if (this.empty()) { return null; }\n        return this.root.elem;\n    }\n    /**\n     * @method push\n     * put things on the heap\n     */\n    public push(...args: T[]): PairingHeap<T> {\n        var pairingNode;\n        for (var i = 0, arg; arg=args[i]; ++i) {\n            pairingNode = new PairingHeap(arg);\n            this.root = this.empty() ?\n                pairingNode : this.root.merge(pairingNode, this.lessThan);\n        }\n        return pairingNode;\n    }\n    /**\n     * @method empty\n     * @return true if no more elements in queue\n     */\n    public empty(): boolean {\n        return !this.root || !this.root.elem;\n    }\n    /**\n     * @method isHeap check heap condition (for testing)\n     * @return true if queue is in valid state\n     */\n    public isHeap(): boolean {\n        return this.root.isHeap(this.lessThan);\n    }\n    /**\n     * @method forEach apply f to each element of the queue\n     * @param f function to apply\n     */\n    public forEach(f) {\n        this.root.forEach(f);\n    }\n    /**\n     * @method pop remove and return the min element from the queue\n     */\n    public pop(): T {\n        if (this.empty()) {\n            return null;\n        }\n        var obj = this.root.min();\n        this.root = this.root.removeMin(this.lessThan);\n        return obj;\n    }\n    /**\n     * @method reduceKey reduce the key value of the specified heap node\n     */\n    public reduceKey(heapNode: PairingHeap<T>, newKey: T, setHeapNode: (e: T, h: PairingHeap<T>)=>void = null): void {\n        this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);\n    }\n    public toString(selector) {\n        return this.root.toString(selector);\n    }\n    /**\n     * @method count\n     * @return number of elements in queue\n     */\n    public count() {\n        return this.root.count();\n    }\n}\n","import {PairingHeap, PriorityQueue} from './pqueue'\n\nclass Neighbour {\n    constructor(public id: number, public distance: number) { }\n}\n\nclass Node {\n    constructor(public id: number) {\n        this.neighbours = [];\n    }\n    neighbours: Neighbour[];\n    d: number;\n    prev: Node;\n    q: PairingHeap<Node>;\n}\n\nclass QueueEntry {\n    constructor(public node: Node, public prev: QueueEntry, public d: number) {}\n}\n\n/**\n * calculates all-pairs shortest paths or shortest paths from a single node\n * @class Calculator\n * @constructor\n * @param n {number} number of nodes\n * @param es {Edge[]} array of edges\n */\nexport class Calculator<Link> {\n    private neighbours: Node[];\n\n    constructor(public n: number, public es: Link[], getSourceIndex: (l: Link) => number, getTargetIndex: (l: Link) => number, getLength: (l: Link) => number) {\n        this.neighbours = new Array(this.n);\n        var i = this.n; while (i--) this.neighbours[i] = new Node(i);\n\n        i = this.es.length; while (i--) {\n            var e = this.es[i];\n            var u: number = getSourceIndex(e), v: number = getTargetIndex(e);\n            var d = getLength(e);\n            this.neighbours[u].neighbours.push(new Neighbour(v, d));\n            this.neighbours[v].neighbours.push(new Neighbour(u, d));\n        }\n    }\n\n    /**\n     * compute shortest paths for graph over n nodes with edges an array of source/target pairs\n     * edges may optionally have a length attribute.  1 is the default.\n     * Uses Johnson's algorithm.\n     *\n     * @method DistanceMatrix\n     * @return the distance matrix\n     */\n    DistanceMatrix(): number[][] {\n        var D = new Array(this.n);\n        for (var i = 0; i < this.n; ++i) {\n            D[i] = this.dijkstraNeighbours(i);\n        }\n        return D;\n    }\n\n    /**\n     * get shortest paths from a specified start node\n     * @method DistancesFromNode\n     * @param start node index\n     * @return array of path lengths\n     */\n    DistancesFromNode(start: number): number[] {\n        return this.dijkstraNeighbours(start);\n    }\n\n    PathFromNodeToNode(start: number, end: number): number[] {\n        return this.dijkstraNeighbours(start, end);\n    }\n\n    // find shortest path from start to end, with the opportunity at\n    // each edge traversal to compute a custom cost based on the\n    // previous edge.  For example, to penalise bends.\n    PathFromNodeToNodeWithPrevCost(\n        start: number,\n        end: number,\n        prevCost: (u:number,v:number,w:number)=>number): number[]\n    {\n        var q = new PriorityQueue<QueueEntry>((a, b) => a.d <= b.d),\n            u: Node = this.neighbours[start],\n            qu: QueueEntry = new QueueEntry(u,null,0),\n            visitedFrom = {};\n        q.push(qu);\n        while(!q.empty()) {\n            qu = q.pop();\n            u = qu.node;\n            if (u.id === end) {\n                break;\n            }\n            var i = u.neighbours.length; while (i--) {\n                var neighbour = u.neighbours[i],\n                    v = this.neighbours[neighbour.id];\n\n                // don't double back\n                if (qu.prev && v.id === qu.prev.node.id) continue;\n\n                // don't retraverse an edge if it has already been explored\n                // from a lower cost route\n                var viduid = v.id + ',' + u.id;\n                if(viduid in visitedFrom && visitedFrom[viduid] <= qu.d)\n                    continue;\n\n                var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0,\n                    t = qu.d + neighbour.distance + cc;\n\n                // store cost of this traversal\n                visitedFrom[viduid] = t;\n                q.push(new QueueEntry(v, qu, t));\n            }\n        }\n        var path:number[] = [];\n        while (qu.prev) {\n            qu = qu.prev;\n            path.push(qu.node.id);\n        }\n        return path;\n    }\n\n    private dijkstraNeighbours(start: number, dest: number = -1): number[] {\n        var q = new PriorityQueue<Node>((a, b) => a.d <= b.d),\n            i = this.neighbours.length,\n            d: number[] = new Array(i);\n        while (i--) {\n            var node: Node = this.neighbours[i];\n            node.d = i === start ? 0 : Number.POSITIVE_INFINITY;\n            node.q = q.push(node);\n        }\n        while (!q.empty()) {\n            // console.log(q.toString(function (u) { return u.id + \"=\" + (u.d === Number.POSITIVE_INFINITY ? \"\\u221E\" : u.d.toFixed(2) )}));\n            var u = q.pop();\n            d[u.id] = u.d;\n            if (u.id === dest) {\n                var path: number[] = [];\n                var v = u;\n                while (typeof v.prev !== 'undefined') {\n                    path.push(v.prev.id);\n                    v = v.prev;\n                }\n                return path;\n            }\n            i = u.neighbours.length; while (i--) {\n                var neighbour = u.neighbours[i];\n                var v = this.neighbours[neighbour.id];\n                var t = u.d + neighbour.distance;\n                if (u.d !== Number.MAX_VALUE && v.d > t) {\n                    v.d = t;\n                    v.prev = u;\n                    q.reduceKey(v.q, v, (e,q)=>e.q = q);\n                }\n            }\n        }\n        return d;\n    }\n}\n","import {Rectangle} from './rectangle'\n    export class Point {\n        x: number;\n        y: number;\n    }\n\n    export class LineSegment {\n        constructor(public x1: number, public y1: number, public x2: number, public y2: number) { }\n    }\n\n    export class PolyPoint extends Point {\n        polyIndex: number;\n    }\n\n    /** tests if a point is Left|On|Right of an infinite line.\n     * @param points P0, P1, and P2\n     * @return >0 for P2 left of the line through P0 and P1\n     *            =0 for P2 on the line\n     *            <0 for P2 right of the line\n     */\n    export function isLeft(P0: Point, P1: Point, P2: Point): number {\n        return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);\n    }\n\n    function above(p: Point, vi: Point, vj: Point): boolean {\n        return isLeft(p, vi, vj) > 0;\n    }\n\n    function below(p: Point, vi: Point, vj: Point): boolean {\n        return isLeft(p, vi, vj) < 0;\n    }\n\n\n    /**\n     * returns the convex hull of a set of points using Andrew's monotone chain algorithm\n     * see: http://geomalgorithms.com/a10-_hull-1.html#Monotone%20Chain\n     * @param S array of points\n     * @return the convex hull as an array of points\n     */\n    export function ConvexHull(S: Point[]): Point[] {\n        var P = S.slice(0).sort((a, b) => a.x !== b.x ? b.x - a.x : b.y - a.y);\n        var n = S.length, i;\n        var minmin = 0;\n        var xmin = P[0].x;\n        for (i = 1; i < n; ++i) {\n            if (P[i].x !== xmin) break;\n        }\n        var minmax = i - 1;\n        var H: Point[] = [];\n        H.push(P[minmin]); // push minmin point onto stack\n        if (minmax === n - 1) { // degenerate case: all x-coords == xmin\n            if (P[minmax].y !== P[minmin].y) // a  nontrivial segment\n                H.push(P[minmax]);\n        } else {\n            // Get the indices of points with max x-coord and min|max y-coord\n            var maxmin, maxmax = n - 1;\n            var xmax = P[n - 1].x;\n            for (i = n - 2; i >= 0; i--)\n                if (P[i].x !== xmax) break;\n            maxmin = i + 1;\n\n            // Compute the lower hull on the stack H\n            i = minmax;\n            while (++i <= maxmin) {\n                // the lower line joins P[minmin]  with P[maxmin]\n                if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)\n                    continue; // ignore P[i] above or on the lower line\n\n                while (H.length > 1) // there are at least 2 points on the stack\n                {\n                    // test if  P[i] is left of the line at the stack top\n                    if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\n                        break; // P[i] is a new hull  vertex\n                    else\n                        H.length -= 1; // pop top point off  stack\n                }\n                if (i != minmin) H.push(P[i]);\n            }\n\n            // Next, compute the upper hull on the stack H above the bottom hull\n            if (maxmax != maxmin) // if  distinct xmax points\n                H.push(P[maxmax]); // push maxmax point onto stack\n            var bot = H.length; // the bottom point of the upper hull stack\n            i = maxmin;\n            while (--i >= minmax) {\n                // the upper line joins P[maxmax]  with P[minmax]\n                if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)\n                    continue; // ignore P[i] below or on the upper line\n\n                while (H.length > bot) // at least 2 points on the upper stack\n                {\n                    // test if  P[i] is left of the line at the stack top\n                    if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)\n                        break; // P[i] is a new hull  vertex\n                    else\n                        H.length -= 1; // pop top point off  stack\n                }\n                if (i != minmin) H.push(P[i]); // push P[i] onto stack\n            }\n        }\n        return H;\n    }\n\n    // apply f to the points in P in clockwise order around the point p\n    export function clockwiseRadialSweep(p: Point, P: Point[], f: (p: Point) => void) {\n        P.slice(0).sort(\n            (a, b) => Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x)\n            ).forEach(f);\n    }\n\n    function nextPolyPoint(p: PolyPoint, ps: PolyPoint[]): PolyPoint {\n        if (p.polyIndex === ps.length - 1) return ps[0];\n        return ps[p.polyIndex + 1];\n    }\n\n    function prevPolyPoint(p: PolyPoint, ps: PolyPoint[]): PolyPoint {\n        if (p.polyIndex === 0) return ps[ps.length - 1];\n        return ps[p.polyIndex - 1];\n    }\n\n    // tangent_PointPolyC(): fast binary search for tangents to a convex polygon\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon\n    //    Output: rtan = index of rightmost tangent point V[rtan]\n    //            ltan = index of leftmost tangent point V[ltan]\n    function tangent_PointPolyC(P: Point, V: Point[]): { rtan: number; ltan: number } {\n        // Rtangent_PointPolyC and Ltangent_PointPolyC require polygon to be\n        // \"closed\" with the first vertex duplicated at end, so V[n-1] = V[0].\n        let Vclosed = V.slice(0);  // Copy V\n        Vclosed.push(V[0]);        // Add V[0] at end\n\n        return { rtan: Rtangent_PointPolyC(P, Vclosed), ltan: Ltangent_PointPolyC(P, Vclosed) };\n    }\n\n\n    // Rtangent_PointPolyC(): binary search for convex polygon right tangent\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon with first\n    //                vertex duplicated as last, so V[n-1] = V[0]\n    //    Return: index \"i\" of rightmost tangent point V[i]\n    function Rtangent_PointPolyC(P: Point, V: Point[]): number {\n        var n = V.length - 1;\n\n        // use binary search for large convex polygons\n        var a: number, b: number, c: number;            // indices for edge chain endpoints\n        var upA: boolean, dnC: boolean;           // test for up direction of edges a and c\n\n        // rightmost tangent = maximum for the isLeft() ordering\n        // test if V[0] is a local maximum\n        if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))\n            return 0;               // V[0] is the maximum tangent point\n\n        for (a = 0, b = n; ;) {          // start chain = [0,n] with V[n]=V[0]\n            if (b - a === 1)\n                if (above(P, V[a], V[b]))\n                    return a;\n                else\n                    return b;\n\n            c = Math.floor((a + b) / 2);        // midpoint of [a,b], and 0<c<n\n            dnC = below(P, V[c + 1], V[c]);\n            if (dnC && !above(P, V[c - 1], V[c]))\n                return c;          // V[c] is the maximum tangent point\n\n            // no max yet, so continue with the binary search\n            // pick one of the two subchains [a,c] or [c,b]\n            upA = above(P, V[a + 1], V[a]);\n            if (upA) {                       // edge a points up\n                if (dnC)                         // edge c points down\n                    b = c;                           // select [a,c]\n                else {                           // edge c points up\n                    if (above(P, V[a], V[c]))     // V[a] above V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] below V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n            else {                           // edge a points down\n                if (!dnC)                        // edge c points up\n                    a = c;                           // select [c,b]\n                else {                           // edge c points down\n                    if (below(P, V[a], V[c]))     // V[a] below V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] above V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n        }\n    }\n\n    // Ltangent_PointPolyC(): binary search for convex polygon left tangent\n    //    Input:  P = a 2D point (exterior to the polygon)\n    //            n = number of polygon vertices\n    //            V = array of vertices for a 2D convex polygon with first\n    //                vertex duplicated as last, so V[n-1] = V[0]\n    //    Return: index \"i\" of leftmost tangent point V[i]\n    function Ltangent_PointPolyC(P: Point, V: Point[]): number {\n        var n = V.length - 1;\n        // use binary search for large convex polygons\n        var a: number, b: number, c: number;             // indices for edge chain endpoints\n        var dnA: boolean, dnC: boolean;           // test for down direction of edges a and c\n\n        // leftmost tangent = minimum for the isLeft() ordering\n        // test if V[0] is a local minimum\n        if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))\n            return 0;               // V[0] is the minimum tangent point\n\n        for (a = 0, b = n; ;) {          // start chain = [0,n] with V[n] = V[0]\n            if (b - a === 1)\n                if (below(P, V[a], V[b]))\n                    return a;\n                else\n                    return b;\n\n            c = Math.floor((a + b) / 2);        // midpoint of [a,b], and 0<c<n\n            dnC = below(P, V[c + 1], V[c]);\n            if (above(P, V[c - 1], V[c]) && !dnC)\n                return c;          // V[c] is the minimum tangent point\n\n            // no min yet, so continue with the binary search\n            // pick one of the two subchains [a,c] or [c,b]\n            dnA = below(P, V[a + 1], V[a]);\n            if (dnA) {                       // edge a points down\n                if (!dnC)                        // edge c points up\n                    b = c;                           // select [a,c]\n                else {                           // edge c points down\n                    if (below(P, V[a], V[c]))     // V[a] below V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] above V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n            else {                           // edge a points up\n                if (dnC)                         // edge c points down\n                    a = c;                           // select [c,b]\n                else {                           // edge c points up\n                    if (above(P, V[a], V[c]))     // V[a] above V[c]\n                        b = c;                       // select [a,c]\n                    else                          // V[a] below V[c]\n                        a = c;                       // select [c,b]\n                }\n            }\n        }\n    }\n\n    // RLtangent_PolyPolyC(): get the RL tangent between two convex polygons\n    //    Input:  m = number of vertices in polygon 1\n    //            V = array of vertices for convex polygon 1 with V[m]=V[0]\n    //            n = number of vertices in polygon 2\n    //            W = array of vertices for convex polygon 2 with W[n]=W[0]\n    //    Output: *t1 = index of tangent point V[t1] for polygon 1\n    //            *t2 = index of tangent point W[t2] for polygon 2\n    export function tangent_PolyPolyC(V: Point[], W: Point[], t1: (a: Point, b: Point[]) => number, t2: (a: Point, b: Point[]) => number, cmp1: (a: Point, b: Point, c: Point) => boolean, cmp2: (a: Point, b: Point, c: Point) => boolean): { t1: number; t2: number } {\n        var ix1: number, ix2: number;      // search indices for polygons 1 and 2\n\n        // first get the initial vertex on each polygon\n        ix1 = t1(W[0], V);   // right tangent from W[0] to V\n        ix2 = t2(V[ix1], W); // left tangent from V[ix1] to W\n\n        // ping-pong linear search until it stabilizes\n        var done = false;                    // flag when done\n        while (!done) {\n            done = true;                     // assume done until...\n            while (true) {\n                if (ix1 === V.length - 1) ix1 = 0;\n                if (cmp1(W[ix2], V[ix1], V[ix1 + 1])) break;\n                ++ix1;                       // get Rtangent from W[ix2] to V\n            }\n            while (true) {\n                if (ix2 === 0) ix2 = W.length - 1;\n                if (cmp2(V[ix1], W[ix2], W[ix2 - 1])) break;\n                --ix2;                       // get Ltangent from V[ix1] to W\n                done = false;                // not done if had to adjust this\n            }\n        }\n        return { t1: ix1, t2: ix2 };\n    }\n\n    export function LRtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        var rl = RLtangent_PolyPolyC(W, V);\n        return { t1: rl.t2, t2: rl.t1 };\n    }\n\n    export function RLtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);\n    }\n\n    export function LLtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);\n    }\n\n    export function RRtangent_PolyPolyC(V: Point[], W: Point[]): { t1: number; t2: number } {\n        return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);\n    }\n\n    export class BiTangent {\n        constructor(public t1: number, public t2: number) { }\n    }\n\n    export class BiTangents {\n        rl: BiTangent;\n        lr: BiTangent;\n        ll: BiTangent;\n        rr: BiTangent;\n    }\n\n    export class TVGPoint extends Point {\n        vv: VisibilityVertex;\n    }\n\n    export class VisibilityVertex {\n        constructor(\n            public id: number,\n            public polyid: number,\n            public polyvertid: number,\n            public p: TVGPoint)\n        {\n            p.vv = this;\n        }\n    }\n\n    export class VisibilityEdge {\n        constructor(\n            public source: VisibilityVertex,\n            public target: VisibilityVertex) { }\n        length(): number {\n            var dx = this.source.p.x - this.target.p.x;\n            var dy = this.source.p.y - this.target.p.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n    }\n\n    export class TangentVisibilityGraph {\n        V: VisibilityVertex[] = [];\n        E: VisibilityEdge[] = [];\n        constructor(public P: TVGPoint[][], g0?: { V: VisibilityVertex[]; E: VisibilityEdge[] }) {\n            if (!g0) {\n                var n = P.length;\n                // For each node...\n                for (var i = 0; i < n; i++) {\n                    var p = P[i];\n                    // For each node vertex.\n                    for (var j = 0; j < p.length; ++j) {\n                        var pj = p[j],\n                            vv = new VisibilityVertex(this.V.length, i, j, pj);\n                        this.V.push(vv);\n                        // For the every iteration but the first, generate an\n                        // edge from the previous visibility vertex to the\n                        // current one.\n                        if (j > 0) this.E.push(new VisibilityEdge(p[j - 1].vv, vv));\n                    }\n                    // Add a visibility edge from the first vertex to the last.\n                    if (p.length > 1) this.E.push(new VisibilityEdge(p[0].vv, p[p.length - 1].vv));\n                }\n                for (var i = 0; i < n - 1; i++) {\n                    var Pi = P[i];\n                    for (var j = i + 1; j < n; j++) {\n                        var Pj = P[j],\n                            t = tangents(Pi, Pj);\n                        for (var q in t) {\n                            var c = t[q],\n                                source = Pi[c.t1], target = Pj[c.t2];\n                            this.addEdgeIfVisible(source, target, i, j);\n                        }\n                    }\n                }\n            } else {\n                this.V = g0.V.slice(0);\n                this.E = g0.E.slice(0);\n            }\n        }\n        addEdgeIfVisible(u: TVGPoint, v: TVGPoint, i1: number, i2: number) {\n            if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {\n                this.E.push(new VisibilityEdge(u.vv, v.vv));\n            }\n        }\n        addPoint(p: TVGPoint, i1: number): VisibilityVertex {\n            var n = this.P.length;\n            this.V.push(new VisibilityVertex(this.V.length, n, 0, p));\n            for (var i = 0; i < n; ++i) {\n                if (i === i1) continue;\n                var poly = this.P[i],\n                    t = tangent_PointPolyC(p, poly);\n                this.addEdgeIfVisible(p, poly[t.ltan], i1, i);\n                this.addEdgeIfVisible(p, poly[t.rtan], i1, i);\n            }\n            return p.vv;\n        }\n        private intersectsPolys(l: LineSegment, i1: number, i2: number): boolean {\n            for (var i = 0, n = this.P.length; i < n; ++i) {\n                if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    function intersects(l: LineSegment, P: Point[]) {\n        var ints = [];\n        for (var i = 1, n = P.length; i < n; ++i) {\n            var int = Rectangle.lineIntersection(\n                l.x1, l.y1,\n                l.x2, l.y2,\n                P[i - 1].x, P[i - 1].y,\n                P[i].x, P[i].y\n                );\n            if (int) ints.push(int);\n        }\n        return ints;\n    }\n\n    export function tangents(V: Point[], W: Point[]): BiTangents\n    {\n        var m = V.length - 1, n = W.length - 1;\n        var bt = new BiTangents();\n        for (var i = 0; i <= m; ++i) {\n            for (var j = 0; j <= n; ++j) {\n                var v1 = V[i == 0 ? m : i - 1];\n                var v2 = V[i];\n                var v3 = V[i == m ? 0 : i + 1];\n                var w1 = W[j == 0 ? n : j - 1];\n                var w2 = W[j];\n                var w3 = W[j == n ? 0 : j + 1];\n                var v1v2w2 = isLeft(v1, v2, w2);\n                var v2w1w2 = isLeft(v2, w1, w2);\n                var v2w2w3 = isLeft(v2, w2, w3);\n                var w1w2v2 = isLeft(w1, w2, v2);\n                var w2v1v2 = isLeft(w2, v1, v2);\n                var w2v2v3 = isLeft(w2, v2, v3);\n                if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0\n                    && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {\n                        bt.ll = new BiTangent(i, j);\n                } else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0\n                    && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {\n                        bt.rr = new BiTangent(i, j);\n                } else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0\n                    && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {\n                        bt.rl = new BiTangent(i, j);\n                } else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0\n                    && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {\n                        bt.lr = new BiTangent(i, j);\n                }\n            }\n        }\n        return bt;\n    }\n\n    function isPointInsidePoly(p: Point, poly: Point[]): boolean {\n        for (var i = 1, n = poly.length; i < n; ++i)\n            if (below(poly[i - 1], poly[i], p)) return false;\n        return true;\n    }\n\n    function isAnyPInQ(p: Point[], q: Point[]): boolean {\n        return !p.every(v => !isPointInsidePoly(v, q));\n    }\n\n    export function polysOverlap(p: Point[], q: Point[]): boolean {\n        if (isAnyPInQ(p, q)) return true;\n        if (isAnyPInQ(q, p)) return true;\n        for (var i = 1, n = p.length; i < n; ++i) {\n            var v = p[i], u = p[i - 1];\n            if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0) return true;\n        }\n        return false;\n    }\n","    var packingOptions = {\n        PADDING: 10,\n        GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,\n        FLOAT_EPSILON: 0.0001,\n        MAX_INERATIONS: 100\n    };\n\n    // assign x, y to nodes while using box packing algorithm for disconnected graphs\n    export function applyPacking(graphs:Array<any>, w, h, node_size, desired_ratio = 1, centerGraph = true) {\n\n        var init_x = 0,\n            init_y = 0,\n\n            svg_width = w,\n            svg_height = h,\n\n            desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1,\n            node_size = typeof node_size !== 'undefined' ? node_size : 0,\n\n            real_width = 0,\n            real_height = 0,\n            min_width = 0,\n\n            global_bottom = 0,\n            line = [];\n\n        if (graphs.length == 0)\n            return;\n\n        /// that would take care of single nodes problem\n        // graphs.forEach(function (g) {\n        //     if (g.array.length == 1) {\n        //         g.array[0].x = 0;\n        //         g.array[0].y = 0;\n        //     }\n        // });\n\n        calculate_bb(graphs);\n        apply(graphs, desired_ratio);\n        if(centerGraph) {\n            put_nodes_to_right_positions(graphs);\n        }\n\n        // get bounding boxes for all separate graphs\n        function calculate_bb(graphs) {\n\n            graphs.forEach(function (g) {\n                calculate_single_bb(g)\n            });\n\n            function calculate_single_bb(graph) {\n                var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE,\n                    max_x = 0, max_y = 0;\n\n                graph.array.forEach(function (v) {\n                    var w = typeof v.width !== 'undefined' ? v.width : node_size;\n                    var h = typeof v.height !== 'undefined' ? v.height : node_size;\n                    w /= 2;\n                    h /= 2;\n                    max_x = Math.max(v.x + w, max_x);\n                    min_x = Math.min(v.x - w, min_x);\n                    max_y = Math.max(v.y + h, max_y);\n                    min_y = Math.min(v.y - h, min_y);\n                });\n\n                graph.width = max_x - min_x;\n                graph.height = max_y - min_y;\n            }\n        }\n\n        //function plot(data, left, right, opt_x, opt_y) {\n        //    // plot the cost function\n        //    var plot_svg = d3.select(\"body\").append(\"svg\")\n        //        .attr(\"width\", function () { return 2 * (right - left); })\n        //        .attr(\"height\", 200);\n\n\n        //    var x = d3.time.scale().range([0, 2 * (right - left)]);\n\n        //    var xAxis = d3.svg.axis().scale(x).orient(\"bottom\");\n        //    plot_svg.append(\"g\").attr(\"class\", \"x axis\")\n        //        .attr(\"transform\", \"translate(0, 199)\")\n        //        .call(xAxis);\n\n        //    var lastX = 0;\n        //    var lastY = 0;\n        //    var value = 0;\n        //    for (var r = left; r < right; r += 1) {\n        //        value = step(data, r);\n        //        // value = 1;\n\n        //        plot_svg.append(\"line\").attr(\"x1\", 2 * (lastX - left))\n        //            .attr(\"y1\", 200 - 30 * lastY)\n        //            .attr(\"x2\", 2 * r - 2 * left)\n        //            .attr(\"y2\", 200 - 30 * value)\n        //            .style(\"stroke\", \"rgb(6,120,155)\");\n\n        //        lastX = r;\n        //        lastY = value;\n        //    }\n\n        //    plot_svg.append(\"circle\").attr(\"cx\", 2 * opt_x - 2 * left).attr(\"cy\", 200 - 30 * opt_y)\n        //        .attr(\"r\", 5).style('fill', \"rgba(0,0,0,0.5)\");\n\n        //}\n\n        // actual assigning of position to nodes\n        function put_nodes_to_right_positions(graphs) {\n            graphs.forEach(function (g) {\n                // calculate current graph center:\n                var center = { x: 0, y: 0 };\n\n                g.array.forEach(function (node) {\n                    center.x += node.x;\n                    center.y += node.y;\n                });\n\n                center.x /= g.array.length;\n                center.y /= g.array.length;\n\n                // calculate current top left corner:\n                var corner = { x: center.x - g.width / 2, y: center.y - g.height / 2 };\n                var offset = { x: g.x - corner.x + svg_width / 2 - real_width / 2, y: g.y - corner.y + svg_height / 2 - real_height / 2};\n\n                // put nodes:\n                g.array.forEach(function (node) {\n                    node.x += offset.x;\n                    node.y += offset.y;\n                });\n            });\n        }\n\n        // starts box packing algorithm\n        // desired ratio is 1 by default\n        function apply(data, desired_ratio) {\n            var curr_best_f = Number.POSITIVE_INFINITY;\n            var curr_best = 0;\n            data.sort(function (a, b) { return b.height - a.height; });\n\n            min_width = data.reduce(function (a, b) {\n                return a.width < b.width ? a.width : b.width;\n            });\n\n            var left = x1 = min_width;\n            var right = x2 = get_entire_width(data);\n            var iterationCounter = 0;\n\n            var f_x1 = Number.MAX_VALUE;\n            var f_x2 = Number.MAX_VALUE;\n            var flag = -1; // determines which among f_x1 and f_x2 to recompute\n\n\n            var dx = Number.MAX_VALUE;\n            var df = Number.MAX_VALUE;\n\n            while ((dx > min_width) || df > packingOptions.FLOAT_EPSILON) {\n\n                if (flag != 1) {\n                    var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;\n                    var f_x1 = step(data, x1);\n                }\n                if (flag != 0) {\n                    var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;\n                    var f_x2 = step(data, x2);\n                }\n\n                dx = Math.abs(x1 - x2);\n                df = Math.abs(f_x1 - f_x2);\n\n                if (f_x1 < curr_best_f) {\n                    curr_best_f = f_x1;\n                    curr_best = x1;\n                }\n\n                if (f_x2 < curr_best_f) {\n                    curr_best_f = f_x2;\n                    curr_best = x2;\n                }\n\n                if (f_x1 > f_x2) {\n                    left = x1;\n                    x1 = x2;\n                    f_x1 = f_x2;\n                    flag = 1;\n                } else {\n                    right = x2;\n                    x2 = x1;\n                    f_x2 = f_x1;\n                    flag = 0;\n                }\n\n                if (iterationCounter++ > 100) {\n                    break;\n                }\n            }\n            // plot(data, min_width, get_entire_width(data), curr_best, curr_best_f);\n            step(data, curr_best);\n        }\n\n        // one iteration of the optimization method\n        // (gives a proper, but not necessarily optimal packing)\n        function step(data, max_width) {\n            line = [];\n            real_width = 0;\n            real_height = 0;\n            global_bottom = init_y;\n\n            for (var i = 0; i < data.length; i++) {\n                var o = data[i];\n                put_rect(o, max_width);\n            }\n\n            return Math.abs(get_real_ratio() - desired_ratio);\n        }\n\n        // looking for a position to one box\n        function put_rect(rect, max_width) {\n\n\n            var parent = undefined;\n\n            for (var i = 0; i < line.length; i++) {\n                if ((line[i].space_left >= rect.height) && (line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width) <= packingOptions.FLOAT_EPSILON) {\n                    parent = line[i];\n                    break;\n                }\n            }\n\n            line.push(rect);\n\n            if (parent !== undefined) {\n                rect.x = parent.x + parent.width + packingOptions.PADDING;\n                rect.y = parent.bottom;\n                rect.space_left = rect.height;\n                rect.bottom = rect.y;\n                parent.space_left -= rect.height + packingOptions.PADDING;\n                parent.bottom += rect.height + packingOptions.PADDING;\n            } else {\n                rect.y = global_bottom;\n                global_bottom += rect.height + packingOptions.PADDING;\n                rect.x = init_x;\n                rect.bottom = rect.y;\n                rect.space_left = rect.height;\n            }\n\n            if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON) real_height = rect.y + rect.height - init_y;\n            if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON) real_width = rect.x + rect.width - init_x;\n        };\n\n        function get_entire_width(data) {\n            var width = 0;\n            data.forEach(function (d) { return width += d.width + packingOptions.PADDING; });\n            return width;\n        }\n\n        function get_real_ratio() {\n            return (real_width / real_height);\n        }\n    }\n\n    /**\n     * connected components of graph\n     * returns an array of {}\n     */\n    export function separateGraphs(nodes, links) {\n        var marks = {};\n        var ways = {};\n        var graphs = [];\n        var clusters = 0;\n\n        for (var i = 0; i < links.length; i++) {\n            var link = links[i];\n            var n1 = link.source;\n            var n2 = link.target;\n            if (ways[n1.index])\n                ways[n1.index].push(n2);\n            else\n                ways[n1.index] = [n2];\n\n            if (ways[n2.index])\n                ways[n2.index].push(n1);\n            else\n                ways[n2.index] = [n1];\n        }\n\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            if (marks[node.index]) continue;\n            explore_node(node, true);\n        }\n\n        function explore_node(n, is_new) {\n            if (marks[n.index] !== undefined) return;\n            if (is_new) {\n                clusters++;\n                graphs.push({ array: [] });\n            }\n            marks[n.index] = clusters;\n            graphs[clusters - 1].array.push(n);\n            var adjacent = ways[n.index];\n            if (!adjacent) return;\n\n            for (var j = 0; j < adjacent.length; j++) {\n                explore_node(adjacent[j], false);\n            }\n        }\n\n        return graphs;\n    }\n","import * as powergraph from './powergraph'\nimport {LinkLengthAccessor, symmetricDiffLinkLengths, jaccardLinkLengths, generateDirectedEdgeConstraints} from './linklengths'\nimport {Descent} from './descent'\nimport {Rectangle, Projection, makeEdgeTo, makeEdgeBetween} from './rectangle'\nimport {Calculator} from './shortestpaths'\nimport {TangentVisibilityGraph, TVGPoint} from './geom'\nimport {separateGraphs, applyPacking} from './handledisconnected'\n    /**\n     * The layout process fires three events:\n     *  - start: layout iterations started\n     *  - tick: fired once per iteration, listen to this to animate\n     *  - end: layout converged, you might like to zoom-to-fit or something at notification of this event\n     */\n    export enum EventType { start, tick, end };\n    export interface Event {\n        type: EventType;\n        alpha: number;\n        stress?: number;\n        listener?: () => void;\n    }\n    export interface InputNode {\n        /**\n         * index in nodes array, this is initialized by Layout.start()\n         */\n        index?: number;\n        /**\n         * x and y will be computed by layout as the Node's centroid\n         */\n        x?: number;\n        /**\n         * x and y will be computed by layout as the Node's centroid\n         */\n        y?: number;\n        /**\n         * specify a width and height of the node's bounding box if you turn on avoidOverlaps\n         */\n        width?: number;\n        /**\n         * specify a width and height of the node's bounding box if you turn on avoidOverlaps\n         */\n        height?: number;\n        /**\n         * selective bit mask.  !=0 means layout will not move.\n         */\n        fixed?: number;\n    }\n    export interface Node extends InputNode {\n      // Client-passed node may be missing these properties, which will be set\n      // upon ingestion\n      x: number;\n      y: number;\n    }\n\n    export interface Group {\n        bounds?: Rectangle;\n        leaves?: Node[];\n        groups?: Group[];\n        padding?: number;\n    }\n\n    function isGroup(g: any): g is Group {\n        return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';\n    }\n\n    export interface Link<NodeRefType> {\n        source: NodeRefType;\n        target: NodeRefType;\n\n        // ideal length the layout should try to achieve for this link\n        length?: number;\n\n        // how hard we should try to satisfy this link's ideal length\n        // must be in the range: 0 < weight <= 1\n        // if unspecified 1 is the default\n        weight?: number;\n    }\n\n    export type LinkNumericPropertyAccessor = (t: Link<Node | number>) => number;\n\n    export interface LinkLengthTypeAccessor extends LinkLengthAccessor<Link<Node | number>> {\n        getType: LinkNumericPropertyAccessor;\n    }\n    /**\n     * Main interface to cola layout.\n     * @class Layout\n     */\n    export class Layout {\n        private _canvasSize = [1, 1];\n        private _linkDistance: number | LinkNumericPropertyAccessor = 20;\n        private _defaultNodeSize: number = 10;\n        private _linkLengthCalculator = null;\n        private _linkType = null;\n        private _avoidOverlaps = false;\n        private _handleDisconnected = true;\n        private _alpha;\n        private _lastStress;\n        private _running = false;\n        private _nodes = [];\n        private _groups = [];\n        private _rootGroup = null;\n        private _links: Link<Node | number>[] = [];\n        private _constraints = [];\n        private _distanceMatrix = null;\n        private _descent: Descent = null;\n        private _directedLinkConstraints = null;\n        private _threshold = 0.01;\n        private _visibilityGraph = null;\n        private _groupCompactness = 1e-6;\n\n        // sub-class and override this property to replace with a more sophisticated eventing mechanism\n        protected event = null;\n\n        // subscribe a listener to an event\n        // sub-class and override this method to replace with a more sophisticated eventing mechanism\n        public on(e: EventType | string, listener: (event?: Event) => void): this {\n            // override me!\n            if (!this.event) this.event = {};\n            if (typeof e === 'string') {\n                this.event[EventType[e]] = listener;\n            } else {\n                this.event[e] = listener;\n            }\n            return this;\n        }\n\n        // a function that is notified of events like \"tick\"\n        // sub-classes can override this method to replace with a more sophisticated eventing mechanism\n        protected trigger(e: Event) {\n            if (this.event && typeof this.event[e.type] !== 'undefined') {\n                this.event[e.type](e);\n            }\n        }\n\n        // a function that kicks off the iteration tick loop\n        // it calls tick() repeatedly until tick returns true (is converged)\n        // subclass and override it with something fancier (e.g. dispatch tick on a timer)\n        protected kick(): void {\n            while (!this.tick());\n        }\n\n        /**\n         * iterate the layout.  Returns true when layout converged.\n         */\n        protected tick(): boolean {\n            if (this._alpha < this._threshold) {\n                this._running = false;\n                this.trigger({ type: EventType.end, alpha: this._alpha = 0, stress: this._lastStress });\n                return true;\n            }\n            const n = this._nodes.length,\n                  m = this._links.length;\n            let o, i;\n\n            this._descent.locks.clear();\n            for (i = 0; i < n; ++i) {\n                o = this._nodes[i];\n                if (o.fixed) {\n                    if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {\n                        o.px = o.x;\n                        o.py = o.y;\n                    }\n                    var p = [o.px, o.py];\n                    this._descent.locks.add(i, p);\n                }\n            }\n\n            let s1 = this._descent.rungeKutta();\n            //var s1 = descent.reduceStress();\n            if (s1 === 0) {\n                this._alpha = 0;\n            } else if (typeof this._lastStress !== 'undefined') {\n                this._alpha = s1; //Math.abs(Math.abs(this._lastStress / s1) - 1);\n            }\n            this._lastStress = s1;\n\n            this.updateNodePositions();\n\n            this.trigger({ type: EventType.tick, alpha: this._alpha, stress: this._lastStress });\n            return false;\n        }\n\n        // copy positions out of descent instance into each of the nodes' center coords\n        private updateNodePositions(): void {\n            const x = this._descent.x[0], y = this._descent.x[1];\n            let o, i = this._nodes.length;\n            while (i--) {\n                o = this._nodes[i];\n                o.x = x[i];\n                o.y = y[i];\n            }\n        }\n\n        /**\n         * the list of nodes.\n         * If nodes has not been set, but links has, then we instantiate a nodes list here, of the correct size,\n         * before returning it.\n         * @property nodes {Array}\n         * @default empty list\n         */\n        nodes(): Array<Node>\n        nodes(v: Array<InputNode>): this\n        nodes(v?: any): any {\n            if (!v) {\n                if (this._nodes.length === 0 && this._links.length > 0) {\n                    // if we have links but no nodes, create the nodes array now with empty objects for the links to point at.\n                    // in this case the links are expected to be numeric indices for nodes in the range 0..n-1 where n is the number of nodes\n                    var n = 0;\n                    this._links.forEach(function (l) {\n                        n = Math.max(n, <number>l.source, <number>l.target);\n                    });\n                    this._nodes = new Array(++n);\n                    for (var i = 0; i < n; ++i) {\n                        this._nodes[i] = {};\n                    }\n                }\n                return this._nodes;\n            }\n            this._nodes = v;\n            return this;\n        }\n\n        /**\n         * a list of hierarchical groups defined over nodes\n         * @property groups {Array}\n         * @default empty list\n         */\n        groups(): Array<Group>\n        groups(x: Array<Group>): this\n        groups(x?: Array<Group>): any {\n            if (!x) return this._groups;\n            this._groups = x;\n            this._rootGroup = {};\n            this._groups.forEach(g => {\n                if (typeof g.padding === \"undefined\")\n                    g.padding = 1;\n                if (typeof g.leaves !== \"undefined\") {\n                    g.leaves.forEach((v, i) => {\n                        if (typeof v === 'number')\n                            (g.leaves[i] = this._nodes[v]).parent = g\n                    });\n                }\n                if (typeof g.groups !== \"undefined\") {\n                    g.groups.forEach((gi, i) => {\n                        if (typeof gi === 'number')\n                            (g.groups[i] = this._groups[gi]).parent = g\n                    });\n                }\n            });\n            this._rootGroup.leaves = this._nodes.filter(v => typeof v.parent === 'undefined');\n            this._rootGroup.groups = this._groups.filter(g => typeof g.parent === 'undefined');\n            return this;\n        }\n\n        powerGraphGroups(f: Function): this {\n            var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);\n            this.groups(g.groups);\n            f(g);\n            return this;\n        }\n\n        /**\n         * if true, the layout will not permit overlaps of the node bounding boxes (defined by the width and height properties on nodes)\n         * @property avoidOverlaps\n         * @type bool\n         * @default false\n         */\n        avoidOverlaps(): boolean\n        avoidOverlaps(v: boolean): this\n        avoidOverlaps(v?: boolean): any {\n            if (!arguments.length) return this._avoidOverlaps;\n            this._avoidOverlaps = v;\n            return this;\n        }\n\n        /**\n         * if true, the final step of the start method will be to nicely pack connected components of the graph.\n         * works best if start() is called with a reasonable number of iterations specified and\n         * each node has a bounding box (defined by the width and height properties on nodes).\n         * @property handleDisconnected\n         * @type bool\n         * @default true\n         */\n        handleDisconnected(): boolean\n        handleDisconnected(v: boolean): this\n        handleDisconnected(v?: boolean): any {\n            if (!arguments.length) return this._handleDisconnected;\n            this._handleDisconnected = v;\n            return this;\n        }\n\n        /**\n         * causes constraints to be generated such that directed graphs are laid out either from left-to-right or top-to-bottom.\n         * a separation constraint is generated in the selected axis for each edge that is not involved in a cycle (part of a strongly connected component)\n         * @param axis {string} 'x' for left-to-right, 'y' for top-to-bottom\n         * @param minSeparation {number|link=>number} either a number specifying a minimum spacing required across all links or a function to return the minimum spacing for each link\n         */\n        flowLayout(axis: string, minSeparation: number|((t: any)=>number)): this {\n            if (!arguments.length) axis = 'y';\n            this._directedLinkConstraints = {\n                axis: axis,\n                getMinSeparation: typeof minSeparation === 'number' ? function () { return minSeparation } : minSeparation\n            };\n            return this;\n        }\n\n        /**\n         * links defined as source, target pairs over nodes\n         * @property links {array}\n         * @default empty list\n         */\n        links(): Array<Link<Node|number>>\n        links(x: Array<Link<Node|number>>): this\n        links(x?: Array<Link<Node|number>>): any {\n            if (!arguments.length) return this._links;\n            this._links = x;\n            return this;\n        }\n\n        /**\n         * list of constraints of various types\n         * @property constraints\n         * @type {array}\n         * @default empty list\n         */\n        constraints(): Array<any>\n        constraints(c: Array<any>): this\n        constraints(c?: Array<any>): any {\n            if (!arguments.length) return this._constraints;\n            this._constraints = c;\n            return this;\n        }\n\n        /**\n         * Matrix of ideal distances between all pairs of nodes.\n         * If unspecified, the ideal distances for pairs of nodes will be based on the shortest path distance between them.\n         * @property distanceMatrix\n         * @type {Array of Array of Number}\n         * @default null\n         */\n        distanceMatrix(): Array<Array<number>>\n        distanceMatrix(d: Array<Array<number>>): this\n        distanceMatrix(d?: any): any {\n            if (!arguments.length) return this._distanceMatrix;\n            this._distanceMatrix = d;\n            return this;\n        }\n\n        /**\n         * Size of the layout canvas dimensions [x,y]. Currently only used to determine the midpoint which is taken as the starting position\n         * for nodes with no preassigned x and y.\n         * @property size\n         * @type {Array of Number}\n         */\n        size(): Array<number>\n        size(x: Array<number>): this\n        size(x?: Array<number>): any {\n            if (!x) return this._canvasSize;\n            this._canvasSize = x;\n            return this;\n        }\n\n        /**\n         * Default size (assume nodes are square so both width and height) to use in packing if node width/height are not specified.\n         * @property defaultNodeSize\n         * @type {Number}\n         */\n        defaultNodeSize(): number\n        defaultNodeSize(x: number): this\n        defaultNodeSize(x?: any): any {\n            if (!x) return this._defaultNodeSize;\n            this._defaultNodeSize = x;\n            return this;\n        }\n\n        /**\n         * The strength of attraction between the group boundaries to each other.\n         * @property defaultNodeSize\n         * @type {Number}\n         */\n        groupCompactness(): number\n        groupCompactness(x: number): this\n        groupCompactness(x?: any): any {\n            if (!x) return this._groupCompactness;\n            this._groupCompactness = x;\n            return this;\n        }\n\n        /**\n         * links have an ideal distance, The automatic layout will compute layout that tries to keep links (AKA edges) as close as possible to this length.\n         */\n        linkDistance(): number\n        linkDistance(): LinkNumericPropertyAccessor\n        linkDistance(x: number): this\n        linkDistance(x: LinkNumericPropertyAccessor): this\n        linkDistance(x?: any): any {\n            if (!x) {\n                return this._linkDistance;\n            }\n            this._linkDistance = typeof x === \"function\" ? x : +x;\n            this._linkLengthCalculator = null;\n            return this;\n        }\n\n        linkType(f: Function | number): this {\n            this._linkType = f;\n            return this;\n        }\n\n        convergenceThreshold(): number\n        convergenceThreshold(x: number): this\n        convergenceThreshold(x?: number): any {\n            if (!x) return this._threshold;\n            this._threshold = typeof x === \"function\" ? x : +x;\n            return this;\n        }\n\n        alpha(): number\n        alpha(x: number): this\n        alpha(x?: number): any {\n            if (!arguments.length) return this._alpha;\n            else {\n                x = +x;\n                if (this._alpha) { // if we're already running\n                    if (x > 0) this._alpha = x; // we might keep it hot\n                    else this._alpha = 0; // or, next tick will dispatch \"end\"\n                } else if (x > 0) { // otherwise, fire it up!\n                    if (!this._running) {\n                        this._running = true;\n                        this.trigger({ type: EventType.start, alpha: this._alpha = x});\n                        this.kick();\n                    }\n                }\n                return this;\n            }\n        }\n\n        getLinkLength(link: Link<Node | number>): number {\n            return typeof this._linkDistance === \"function\" ? +((<LinkNumericPropertyAccessor>this._linkDistance)(link)) : <number>this._linkDistance;\n        }\n\n        static setLinkLength(link: Link<Node|number>, length: number) {\n            link.length = length;\n        }\n\n        getLinkType(link: Link<Node | number>): number {\n            return typeof this._linkType === \"function\" ? this._linkType(link) : 0;\n        }\n\n        linkAccessor: LinkLengthTypeAccessor = {\n            getSourceIndex: Layout.getSourceIndex,\n            getTargetIndex: Layout.getTargetIndex,\n            setLength: Layout.setLinkLength,\n            getType: l => typeof this._linkType === \"function\" ? this._linkType(l) : 0\n        };\n\n        /**\n         * compute an ideal length for each link based on the graph structure around that link.\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: sqrt(|a union b| - |a intersection b|)\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\n         * don't have to have been assigned before invoking this function.\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\n         */\n        symmetricDiffLinkLengths(idealLength: number, w: number = 1): this {\n            this.linkDistance(l => idealLength * l.length);\n            this._linkLengthCalculator = () => symmetricDiffLinkLengths(this._links, this.linkAccessor, w);\n            return this;\n        }\n\n        /**\n         * compute an ideal length for each link based on the graph structure around that link.\n         * you can use this (for example) to create extra space around hub-nodes in dense graphs.\n         * In particular this calculation is based on the \"symmetric difference\" in the neighbour sets of the source and target:\n         * i.e. if neighbours of source is a and neighbours of target are b then calculation is: |a intersection b|/|a union b|\n         * Actual computation based on inspection of link structure occurs in start(), so links themselves\n         * don't have to have been assigned before invoking this function.\n         * @param {number} [idealLength] the base length for an edge when its source and start have no other common neighbours (e.g. 40)\n         * @param {number} [w] a multiplier for the effect of the length adjustment (e.g. 0.7)\n         */\n        jaccardLinkLengths(idealLength: number, w: number = 1): this {\n            this.linkDistance(l => idealLength * l.length);\n            this._linkLengthCalculator = () => jaccardLinkLengths(this._links, this.linkAccessor, w);\n            return this;\n        }\n\n        /**\n         * start the layout process\n         * @method start\n         * @param {number} [initialUnconstrainedIterations=0] unconstrained initial layout iterations\n         * @param {number} [initialUserConstraintIterations=0] initial layout iterations with user-specified constraints\n         * @param {number} [initialAllConstraintsIterations=0] initial layout iterations with all constraints including non-overlap\n         * @param {number} [gridSnapIterations=0] iterations of \"grid snap\", which pulls nodes towards grid cell centers - grid of size node[0].width - only really makes sense if all nodes have the same width and height\n         * @param [keepRunning=true] keep iterating asynchronously via the tick method\n         * @param [centerGraph=true] Center graph on restart\n         */\n        start(\n            initialUnconstrainedIterations: number = 0,\n            initialUserConstraintIterations: number = 0,\n            initialAllConstraintsIterations: number = 0,\n            gridSnapIterations: number = 0,\n            keepRunning = true,\n            centerGraph = true,\n        ): this {\n            var i: number,\n                j: number,\n                n = (<Array<any>>this.nodes()).length,\n                N = n + 2 * this._groups.length,\n                m = this._links.length,\n                w = this._canvasSize[0],\n                h = this._canvasSize[1];\n\n            var x = new Array(N), y = new Array(N);\n\n            var G = null;\n\n            var ao = this._avoidOverlaps;\n\n            this._nodes.forEach((v, i) => {\n                v.index = i;\n                if (typeof v.x === 'undefined') {\n                    v.x = w / 2, v.y = h / 2;\n                }\n                x[i] = v.x, y[i] = v.y;\n            });\n\n            if (this._linkLengthCalculator) this._linkLengthCalculator();\n\n            //should we do this to clearly label groups?\n            //this._groups.forEach((g, i) => g.groupIndex = i);\n\n            var distances;\n            if (this._distanceMatrix) {\n                // use the user specified distanceMatrix\n                distances = this._distanceMatrix;\n            } else {\n                // construct an n X n distance matrix based on shortest paths through graph (with respect to edge.length).\n                distances = (new Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, l=> this.getLinkLength(l))).DistanceMatrix();\n\n                // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\n                // otherwise 2. (\n                G = Descent.createSquareMatrix(N, () => 2);\n                this._links.forEach(l => {\n                    if (typeof l.source == \"number\") l.source = this._nodes[<number>l.source];\n                    if (typeof l.target == \"number\") l.target = this._nodes[<number>l.target];\n                });\n                this._links.forEach(e => {\n                    const u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);\n                    G[u][v] = G[v][u] = e.weight || 1;\n                });\n            }\n\n            var D = Descent.createSquareMatrix(N, function (i, j) {\n                return distances[i][j];\n            });\n\n            if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {\n                var i = n;\n                var addAttraction = (i, j, strength, idealDistance) => {\n                    G[i][j] = G[j][i] = strength;\n                    D[i][j] = D[j][i] = idealDistance;\n                };\n                this._groups.forEach(g => {\n                    addAttraction(i, i + 1, this._groupCompactness, 0.1);\n\n                    // todo: add terms here attracting children of the group to the group dummy nodes\n                    //if (typeof g.leaves !== 'undefined')\n                    //    g.leaves.forEach(l => {\n                    //        addAttraction(l.index, i, 1e-4, 0.1);\n                    //        addAttraction(l.index, i + 1, 1e-4, 0.1);\n                    //    });\n                    //if (typeof g.groups !== 'undefined')\n                    //    g.groups.forEach(g => {\n                    //        var gid = n + g.groupIndex * 2;\n                    //        addAttraction(gid, i, 0.1, 0.1);\n                    //        addAttraction(gid + 1, i, 0.1, 0.1);\n                    //        addAttraction(gid, i + 1, 0.1, 0.1);\n                    //        addAttraction(gid + 1, i + 1, 0.1, 0.1);\n                    //    });\n\n                    if (typeof g.bounds === 'undefined') {\n                        x[i] = w / 2, y[i++] = h / 2;\n                        x[i] = w / 2, y[i++] = h / 2;\n                    } else {\n                        x[i] = g.bounds.x, y[i++] = g.bounds.y;\n                        x[i] = g.bounds.X, y[i++] = g.bounds.Y;\n                    }\n                });\n            } else this._rootGroup = { leaves: this._nodes, groups: [] };\n\n            var curConstraints = this._constraints || [];\n            if (this._directedLinkConstraints) {\n                (<any>this.linkAccessor).getMinSeparation = this._directedLinkConstraints.getMinSeparation;\n                curConstraints = curConstraints.concat(generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, <any>(this.linkAccessor)));\n\n                // todo: add containment constraints between group dummy nodes and their children\n            }\n\n            this.avoidOverlaps(false);\n            this._descent = new Descent([x, y], D);\n\n            this._descent.locks.clear();\n            for (var i = 0; i < n; ++i) {\n                var o = this._nodes[i];\n                if (o.fixed) {\n                    o.px = o.x;\n                    o.py = o.y;\n                    var p = [o.x, o.y];\n                    this._descent.locks.add(i, p);\n                }\n            }\n            this._descent.threshold = this._threshold;\n\n            // apply initialIterations without user constraints or nonoverlap constraints\n            // if groups are specified, dummy nodes and edges will be added to untangle\n            // with respect to group connectivity\n            this.initialLayout(initialUnconstrainedIterations, x, y);\n\n            // apply initialIterations with user constraints but no nonoverlap constraints\n            if (curConstraints.length > 0) this._descent.project = new Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();\n            this._descent.run(initialUserConstraintIterations);\n            this.separateOverlappingComponents(w, h, centerGraph);\n\n            // subsequent iterations will apply all constraints\n            this.avoidOverlaps(ao);\n            if (ao) {\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\n                this._descent.project = new Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();\n                this._nodes.forEach(function (v, i) { x[i] = v.x, y[i] = v.y; });\n            }\n\n            // allow not immediately connected nodes to relax apart (p-stress)\n            this._descent.G = G;\n            this._descent.run(initialAllConstraintsIterations);\n\n            if (gridSnapIterations) {\n                this._descent.snapStrength = 1000;\n                this._descent.snapGridSize = this._nodes[0].width;\n                this._descent.numGridSnapNodes = n;\n                this._descent.scaleSnapByMaxH = n != N; // if we have groups then need to scale hessian so grid forces still apply\n                var G0 = Descent.createSquareMatrix(N,(i, j) => {\n                    if (i >= n || j >= n) return G[i][j];\n                    return 0\n                });\n                this._descent.G = G0;\n                this._descent.run(gridSnapIterations);\n            }\n\n            this.updateNodePositions();\n            this.separateOverlappingComponents(w, h, centerGraph);\n            return keepRunning ? this.resume() : this;\n        }\n\n        private initialLayout(iterations: number, x: number[], y: number[]) {\n            if (this._groups.length > 0 && iterations > 0) {\n                // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\n                // todo: edges attached to groups are replaced with edges connected to the corresponding group dummy node\n                var n = this._nodes.length;\n                var edges = this._links.map(e => <any>{ source: (<Node>e.source).index, target: (<Node>e.target).index });\n                var vs = this._nodes.map(v => <any>{ index: v.index });\n                this._groups.forEach((g, i) => {\n                    vs.push(<any>{ index: g.index = n + i });\n                });\n                this._groups.forEach((g, i) => {\n                    if (typeof g.leaves !== 'undefined')\n                        g.leaves.forEach(v => edges.push({ source: g.index, target: v.index }));\n                    if (typeof g.groups !== 'undefined')\n                        g.groups.forEach(gg => edges.push({ source: g.index, target: gg.index }));\n                });\n\n                // layout the flat graph with dummy nodes and edges\n                new Layout()\n                    .size(this.size())\n                    .nodes(vs)\n                    .links(edges)\n                    .avoidOverlaps(false)\n                    .linkDistance(this.linkDistance())\n                    .symmetricDiffLinkLengths(5)\n                    .convergenceThreshold(1e-4)\n                    .start(iterations, 0, 0, 0, false);\n\n                this._nodes.forEach(v => {\n                    x[v.index] = vs[v.index].x;\n                    y[v.index] = vs[v.index].y;\n                });\n            } else {\n                this._descent.run(iterations);\n            }\n        }\n\n        // recalculate nodes position for disconnected graphs\n        private separateOverlappingComponents(width: number, height: number, centerGraph: boolean = true): void {\n            // recalculate nodes position for disconnected graphs\n            if (!this._distanceMatrix && this._handleDisconnected) {\n                let x = this._descent.x[0], y = this._descent.x[1];\n                this._nodes.forEach(function (v, i) { v.x = x[i], v.y = y[i]; });\n                var graphs = separateGraphs(this._nodes, this._links);\n                applyPacking(graphs, width, height, this._defaultNodeSize, 1, centerGraph);\n                this._nodes.forEach((v, i) => {\n                    this._descent.x[0][i] = v.x, this._descent.x[1][i] = v.y;\n                    if (v.bounds) {\n                        v.bounds.setXCentre(v.x);\n                        v.bounds.setYCentre(v.y);\n                    }\n                });\n            }\n        }\n\n        resume(): this {\n            return this.alpha(0.1);\n        }\n\n        stop(): this {\n            return this.alpha(0);\n        }\n\n        /// find a visibility graph over the set of nodes.  assumes all nodes have a\n        /// bounds property (a rectangle) and that no pair of bounds overlaps.\n        prepareEdgeRouting(nodeMargin: number = 0) {\n            this._visibilityGraph = new TangentVisibilityGraph(\n                this._nodes.map(function (v) {\n                    return v.bounds.inflate(-nodeMargin).vertices();\n                }));\n        }\n\n        /**\n         * find a route avoiding node bounds for the given edge.\n         * assumes the visibility graph has been created (by prepareEdgeRouting method)\n         * and also assumes that nodes have an index property giving their position in the\n         * node array.  This index property is created by the start() method.\n         * @param [edge] The edge to generate a route for.\n         * @param {number} [ah] The size of the arrow head, a distance to shorten the end\n         *                      of the edge by.  Defaults to 5.\n         */\n        routeEdge(edge, ah: number = 5, draw) {\n            var lineData = [];\n            //if (d.source.id === 10 && d.target.id === 11) {\n            //    debugger;\n            //}\n            var vg2 = new TangentVisibilityGraph(this._visibilityGraph.P, { V: this._visibilityGraph.V, E: this._visibilityGraph.E }),\n                port1 = <TVGPoint>{ x: edge.source.x, y: edge.source.y },\n                port2 = <TVGPoint>{ x: edge.target.x, y: edge.target.y },\n                start = vg2.addPoint(port1, edge.source.index),\n                end = vg2.addPoint(port2, edge.target.index);\n            vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);\n            if (typeof draw !== 'undefined') {\n                draw(vg2);\n            }\n            var sourceInd = e => e.source.id, targetInd = e => e.target.id, length = e => e.length(),\n                spCalc = new Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length),\n                shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);\n            if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {\n                let route = makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, ah);\n                lineData = [route.sourceIntersection, route.arrowStart];\n            } else {\n                var n = shortestPath.length - 2,\n                    p = vg2.V[shortestPath[n]].p,\n                    q = vg2.V[shortestPath[0]].p,\n                    lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];\n                for (var i = n; i >= 0; --i)\n                    lineData.push(vg2.V[shortestPath[i]].p);\n                lineData.push(makeEdgeTo(q, edge.target.innerBounds, ah));\n            }\n            //lineData.forEach((v, i) => {\n            //    if (i > 0) {\n            //        var u = lineData[i - 1];\n            //        this._nodes.forEach(function (node) {\n            //            if (node.id === getSourceIndex(d) || node.id === getTargetIndex(d)) return;\n            //            var ints = node.innerBounds.lineIntersections(u.x, u.y, v.x, v.y);\n            //            if (ints.length > 0) {\n            //                debugger;\n            //            }\n            //        })\n            //    }\n            //})\n            return lineData;\n        }\n\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\n        static getSourceIndex(e: Link<Node | number>): number {\n            return typeof e.source === 'number' ? <number>e.source : (<Node>e.source).index;\n        }\n\n        //The link source and target may be just a node index, or they may be references to nodes themselves.\n        static getTargetIndex(e: Link<Node | number>): number {\n            return typeof e.target === 'number' ? <number>e.target : (<Node>e.target).index;\n        }\n\n        // Get a string ID for a given link.\n        static linkId(e: Link<Node | number>): string {\n            return Layout.getSourceIndex(e) + \"-\" + Layout.getTargetIndex(e);\n        }\n\n        // The fixed property has three bits:\n        // Bit 1 can be set externally (e.g., d.fixed = true) and show persist.\n        // Bit 2 stores the dragging state, from mousedown to mouseup.\n        // Bit 3 stores the hover state, from mouseover to mouseout.\n        static dragStart(d: Node | Group) {\n            if (isGroup(d)) {\n                Layout.storeOffset(d, Layout.dragOrigin(d));\n            } else {\n                Layout.stopNode(d);\n                d.fixed |= 2; // set bit 2\n            }\n        }\n\n        // we clobber any existing desired positions for nodes\n        // in case another tick event occurs before the drag\n        private static stopNode(v: Node) {\n            (<any>v).px = v.x;\n            (<any>v).py = v.y;\n        }\n\n        // we store offsets for each node relative to the centre of the ancestor group\n        // being dragged in a pair of properties on the node\n        private static storeOffset(d: Group, origin: { x: number, y: number }) {\n            if (typeof d.leaves !== 'undefined') {\n                d.leaves.forEach(v => {\n                    v.fixed |= 2;\n                    Layout.stopNode(v);\n                    (<any>v)._dragGroupOffsetX = v.x - origin.x;\n                    (<any>v)._dragGroupOffsetY = v.y - origin.y;\n                });\n            }\n            if (typeof d.groups !== 'undefined') {\n                d.groups.forEach(g => Layout.storeOffset(g, origin));\n            }\n        }\n\n        // the drag origin is taken as the centre of the node or group\n        static dragOrigin(d: Node | Group): { x: number, y: number } {\n            if (isGroup(d)) {\n                return {\n                    x: d.bounds.cx(),\n                    y: d.bounds.cy()\n                };\n            } else {\n                return d;\n            }\n        }\n\n        // for groups, the drag translation is propagated down to all of the children of\n        // the group.\n        static drag(d: Node | Group, position: { x: number, y: number }) {\n            if (isGroup(d)) {\n                if (typeof d.leaves !== 'undefined') {\n                    d.leaves.forEach(v => {\n                        d.bounds.setXCentre(position.x);\n                        d.bounds.setYCentre(position.y);\n                        (<any>v).px = (<any>v)._dragGroupOffsetX + position.x;\n                        (<any>v).py = (<any>v)._dragGroupOffsetY + position.y;\n                    });\n                }\n                if (typeof d.groups !== 'undefined') {\n                    d.groups.forEach(g => Layout.drag(g, position));\n                }\n            } else {\n                (<any>d).px = position.x;\n                (<any>d).py = position.y;\n            }\n        }\n\n        // we unset only bits 2 and 3 so that the user can fix nodes with another a different\n        // bit such that the lock persists between drags\n        static dragEnd(d) {\n            if (isGroup(d)) {\n                if (typeof d.leaves !== 'undefined') {\n                    d.leaves.forEach(v => {\n                        Layout.dragEnd(v);\n                        delete (<any>v)._dragGroupOffsetX;\n                        delete (<any>v)._dragGroupOffsetY;\n                    });\n                }\n                if (typeof d.groups !== 'undefined') {\n                    d.groups.forEach(Layout.dragEnd);\n                }\n            } else {\n                d.fixed &= ~6; // unset bits 2 and 3\n                //d.fixed = 0;\n            }\n        }\n\n        // in d3 hover temporarily locks nodes, currently not used in cola\n        static mouseOver(d) {\n            d.fixed |= 4; // set bit 3\n            d.px = d.x, d.py = d.y; // set velocity to zero\n        }\n\n        // in d3 hover temporarily locks nodes, currently not used in cola\n        static mouseOut(d) {\n            d.fixed &= ~4; // unset bit 3\n        }\n    }\n","import {Layout, EventType, Event} from './layout'\n\n    export class LayoutAdaptor extends Layout {\n\n        // dummy functions in case not defined by client\n        trigger(e: Event) {};\n        kick() {};\n        drag() {};\n        on(eventType: EventType | string, listener: () => void) : this { return this; };\n\n        dragstart: (d:any) => void;\n        dragStart: (d:any) => void;\n        dragend: (d:any) => void;\n        dragEnd: (d:any) => void;\n\n        constructor( options ) {\n            super();\n\n            // take in implementation as defined by client\n\n            var self = this;\n            var o = options;\n\n            if ( o.trigger ) {\n                this.trigger = o.trigger;\n            }\n\n            if ( o.kick ){\n                this.kick = o.kick;\n            }\n\n            if ( o.drag ){\n                this.drag = o.drag;\n            }\n\n            if ( o.on ){\n                this.on = o.on;\n            }\n\n            this.dragstart = this.dragStart = Layout.dragStart;\n            this.dragend = this.dragEnd = Layout.dragEnd;\n        }\n    }\n\n    /**\n     * provides an interface for use with any external graph system (e.g. Cytoscape.js):\n     */\n    export function adaptor( options ): LayoutAdaptor {\n        return new LayoutAdaptor( options );\n    }\n","////<reference path=\"../extern/d3v3.d.ts\"/>\n////commented out the reference, because the path ended up in the typings, which\n////makes it impossible import in other projects.\n// declare const d3;\n\n\nimport {Layout, EventType, Event} from './layout';\nimport {ID3StyleLayoutAdaptor} from './d3adaptor'\n\n    /**\n     * @internal\n     */\n    export class D3StyleLayoutAdaptor extends Layout implements ID3StyleLayoutAdaptor {\n        protected readonly event: any;\n\n        trigger(e: Event) {\n            var d3event = { type: EventType[e.type], alpha: e.alpha, stress: e.stress };\n            this.event[d3event.type](d3event); // via d3 dispatcher, e.g. event.start(e);\n        }\n\n        // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true\n        kick() {\n            this.d3Context.timer(() => super.tick());\n        }\n\n        // a function to allow for dragging of nodes\n        drag: () => any;\n\n        private d3Context: any;\n\n        constructor(d3Context: any = self.d3) {\n            super();\n            this.d3Context = d3Context;\n            this.event = d3Context.dispatch(EventType[EventType.start], EventType[EventType.tick], EventType[EventType.end]);\n            // bit of trickyness remapping 'this' so we can reference it in the function body.\n            var d3layout = this;\n            var drag;\n            this.drag = function () {\n                if (!drag) {\n                    var drag = d3Context.behavior.drag()\n                        .origin(Layout.dragOrigin)\n                        .on(\"dragstart.d3adaptor\", Layout.dragStart)\n                        .on(\"drag.d3adaptor\", d => {\n                            Layout.drag(d, <any>d3layout.d3Context.event);\n                            d3layout.resume(); // restart annealing\n                        })\n                        .on(\"dragend.d3adaptor\", Layout.dragEnd);\n                }\n\n                if (!arguments.length) return drag;\n\n                // this is the context of the function, i.e. the d3 selection\n                this//.on(\"mouseover.adaptor\", colaMouseover)\n                //.on(\"mouseout.adaptor\", colaMouseout)\n                    .call(drag);\n            }\n        }\n\n        // a function for binding to events on the adapter\n        on(eventType: EventType | string, listener: () => void): this {\n            if (typeof eventType === 'string') {\n                this.event.on(eventType, listener);\n            } else {\n                this.event.on(EventType[eventType], listener);\n            }\n            return this;\n        }\n    }\n","import {dispatch} from 'd3-dispatch'\nimport {timer} from 'd3-timer'\nimport {drag as d3drag} from 'd3-drag'\nimport {Layout, EventType, Event} from './layout'\nimport {ID3StyleLayoutAdaptor} from './d3adaptor'\n\nexport interface D3Context {\n    timer: typeof timer;\n    drag: typeof d3drag;\n    dispatch: typeof dispatch;\n    event: any;\n}\n\n/**\n * @internal\n */\nexport class D3NextStyleLayoutAdaptor extends Layout implements ID3StyleLayoutAdaptor {\n    event:any;\n    trigger(e: Event) {\n        var d3event = { type: EventType[e.type], alpha: e.alpha, stress: e.stress };\n        // the dispatcher is actually expecting something of type EventTarget as the second argument\n        // so passing the thing above is totally abusing the pattern... not sure what to do about this yet\n        this.event.call(d3event.type, <any>d3event); // via d3 dispatcher, e.g. event.start(e);\n    }\n\n    // iterate layout using a d3.timer, which queues calls to tick repeatedly until tick returns true\n    kick() {\n        var t = this.d3Context.timer(() => super.tick() && t.stop());\n    }\n\n    // a function to allow for dragging of nodes\n    drag: () => any;\n\n    /**\n     * @internal\n     */\n    private readonly d3Context: D3Context;\n\n    constructor(d3Context: D3Context) {\n        super();\n        this.d3Context = d3Context;\n        this.event = d3Context.dispatch(EventType[EventType.start], EventType[EventType.tick], EventType[EventType.end]);\n\n        // bit of trickyness remapping 'this' so we can reference it in the function body.\n        var d3layout = this;\n        var drag;\n        this.drag = function () {\n            if (!drag) {\n                var drag = d3Context.drag()\n                    .subject(Layout.dragOrigin)\n                    .on(\"start.d3adaptor\", (event: any, d: any) => Layout.dragStart(d))\n                    .on(\"drag.d3adaptor\", (event: any, d) => {\n                        Layout.drag(<any>d, event);\n                        d3layout.resume(); // restart annealing\n                    })\n                    .on(\"end.d3adaptor\", (event: any, d) => Layout.dragEnd(d));\n            }\n\n            if (!arguments.length) return drag;\n\n            // this is the context of the function, i.e. the d3 selection\n            //this//.on(\"mouseover.adaptor\", colaMouseover)\n            //.on(\"mouseout.adaptor\", colaMouseout)\n            arguments[0].call(drag);\n        }\n    }\n\n    // a function for binding to events on the adapter\n    on(eventType: EventType | string, listener: () => void): this {\n        if (typeof eventType === 'string') {\n            this.event.on(eventType, listener);\n        } else {\n            this.event.on(EventType[eventType], listener);\n        }\n        return this;\n    }\n}\n","import {Point} from './geom'\nimport {Rectangle} from './rectangle'\nimport {Constraint, Solver, Variable} from './vpsc'\nimport {Calculator} from './shortestpaths'\n    export interface NodeAccessor<Node>{\n        getChildren(v:Node) : number[];\n        getBounds(v:Node) : Rectangle;\n    }\n    export class NodeWrapper {\n        leaf: boolean;\n        parent: NodeWrapper;\n        ports: Vert[];\n        constructor(public id: number, public rect: Rectangle, public children: number[]) {\n            this.leaf = typeof children === 'undefined' || children.length === 0;\n        }\n    }\n    export class Vert {\n        constructor(public id: number, public x:number, public y: number, public node: NodeWrapper = null, public line = null) {}\n    }\n\n    export class LongestCommonSubsequence<T> {\n        length: number;\n        si: number;\n        ti: number;\n        reversed: boolean;\n        constructor(public s: T[], public t: T[]) {\n            var mf = LongestCommonSubsequence.findMatch(s, t);\n            var tr = t.slice(0).reverse();\n            var mr = LongestCommonSubsequence.findMatch(s, tr);\n            if (mf.length >= mr.length) {\n                this.length = mf.length;\n                this.si = mf.si;\n                this.ti = mf.ti;\n                this.reversed = false;\n            } else {\n                this.length = mr.length;\n                this.si = mr.si;\n                this.ti = t.length - mr.ti - mr.length;\n                this.reversed = true;\n            }\n        }\n        private static findMatch<T>(s: T[], t: T[]) {\n            var m = s.length;\n            var n = t.length;\n            var match = { length: 0, si: -1, ti: -1 };\n            var l = new Array(m);\n            for (var i = 0; i < m; i++) {\n                l[i] = new Array(n);\n                for (var j = 0; j < n; j++)\n                    if (s[i] === t[j]) {\n                        var v = l[i][j] = (i === 0 || j === 0) ? 1 : l[i - 1][j - 1] + 1;\n                        if (v > match.length) {\n                            match.length = v;\n                            match.si = i - v + 1;\n                            match.ti = j - v + 1;\n                        };\n                    } else l[i][j] = 0;\n            }\n            return match;\n        }\n        getSequence(): T[]{\n            return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];\n        }\n    }\n    // a horizontal or vertical line of nodes\n    export interface GridLine {\n        nodes: NodeWrapper[];\n        pos: number;\n    }\n    export class GridRouter<Node> {\n        leaves: NodeWrapper[] = null;\n        groups: NodeWrapper[];\n        nodes: NodeWrapper[];\n        cols: GridLine[];\n        rows: GridLine[];\n        root;\n        verts: Vert[];\n        edges;\n        backToFront;\n        obstacles;\n        passableEdges;\n        private avg(a) { return a.reduce((x, y) => x + y) / a.length }\n\n        // in the given axis, find sets of leaves overlapping in that axis\n        // center of each GridLine is average of all nodes in column\n        private getGridLines(axis): GridLine[] {\n            var columns = [];\n            var ls = this.leaves.slice(0, this.leaves.length);\n            while (ls.length > 0) {\n                // find a column of all leaves overlapping in axis with the first leaf\n                let overlapping = ls.filter(v=> v.rect['overlap' + axis.toUpperCase()](ls[0].rect));\n                let col = {\n                    nodes: overlapping,\n                    pos: this.avg(overlapping.map(v=> v.rect['c' + axis]()))\n                };\n                columns.push(col);\n                col.nodes.forEach(v=> ls.splice(ls.indexOf(v), 1));\n            }\n            columns.sort((a, b) => a.pos - b.pos)\n            return columns;\n        }\n\n        // get the depth of the given node in the group hierarchy\n        private getDepth(v) {\n            var depth = 0;\n            while (v.parent !== this.root) {\n                depth++;\n                v = v.parent;\n            }\n            return depth;\n        }\n\n        // medial axes between node centres and also boundary lines for the grid\n        private midPoints(a) {\n            if (a.length === 1) {\n                return [a[0]]\n            }\n\n            var gap = a[1] - a[0];\n            var mids = [a[0] - gap / 2];\n            for (var i = 1; i < a.length; i++) {\n                mids.push((a[i] + a[i - 1]) / 2);\n            }\n            mids.push(a[a.length - 1] + gap / 2);\n            return mids;\n        }\n\n        constructor(public originalnodes: Node[], accessor: NodeAccessor<Node>, public groupPadding: number = 12) {\n            this.nodes = originalnodes.map((v, i) => new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v)));\n            this.leaves = this.nodes.filter(v=> v.leaf);\n            this.groups = this.nodes.filter(g=> !g.leaf);\n            this.cols = this.getGridLines('x');\n            this.rows = this.getGridLines('y');\n\n            // create parents for each node or group that is a member of another's children\n            this.groups.forEach(v=>\n                v.children.forEach(c=> this.nodes[<number>c].parent = v));\n\n            // root claims the remaining orphans\n            this.root = { children: [] };\n            this.nodes.forEach(v=> {\n                if (typeof v.parent === 'undefined') {\n                    v.parent = this.root;\n                    this.root.children.push(v.id);\n                }\n\n                // each node will have grid vertices associated with it,\n                // some inside the node and some on the boundary\n                // leaf nodes will have exactly one internal node at the center\n                // and four boundary nodes\n                // groups will have potentially many of each\n                v.ports = []\n            });\n\n            // nodes ordered by their position in the group hierarchy\n            this.backToFront = this.nodes.slice(0);\n            this.backToFront.sort((x, y) => this.getDepth(x) - this.getDepth(y));\n\n            // compute boundary rectangles for each group\n            // has to be done from front to back, i.e. inside groups to outside groups\n            // such that each can be made large enough to enclose its interior\n            var frontToBackGroups = this.backToFront.slice(0).reverse().filter(g=> !g.leaf);\n            frontToBackGroups.forEach(v=> {\n                var r = Rectangle.empty();\n                v.children.forEach(c=> r = r.union(this.nodes[c].rect));\n                v.rect = r.inflate(this.groupPadding);\n            });\n\n            var colMids = this.midPoints(this.cols.map(r=> r.pos));\n            var rowMids = this.midPoints(this.rows.map(r=> r.pos));\n\n            // setup extents of lines\n            var rowx = colMids[0], rowX = colMids[colMids.length - 1];\n            var coly = rowMids[0], colY = rowMids[rowMids.length - 1];\n\n            // horizontal lines\n            var hlines = this.rows.map(r=> <any>{ x1: rowx, x2: rowX, y1: r.pos, y2: r.pos })\n                .concat(rowMids.map(m=> <any>{ x1: rowx, x2: rowX, y1: m, y2: m }));\n\n            // vertical lines\n            var vlines = this.cols.map(c=> <any>{ x1: c.pos, x2: c.pos, y1: coly, y2: colY })\n                .concat(colMids.map(m=> <any>{ x1: m, x2: m, y1: coly, y2: colY }));\n\n            // the full set of lines\n            var lines = hlines.concat(vlines);\n\n            // we record the vertices associated with each line\n            lines.forEach(l=> l.verts = []);\n\n            // the routing graph\n            this.verts = [];\n            this.edges = [];\n\n            // create vertices at the crossings of horizontal and vertical grid-lines\n            hlines.forEach(h=>\n                vlines.forEach(v=> {\n                    var p = new Vert(this.verts.length, v.x1, h.y1);\n                    h.verts.push(p);\n                    v.verts.push(p);\n                    this.verts.push(p);\n\n                    // assign vertices to the nodes immediately under them\n                    var i = this.backToFront.length;\n                    while (i-- > 0) {\n                        var node = this.backToFront[i],\n                            r = node.rect;\n                        var dx = Math.abs(p.x - r.cx()),\n                            dy = Math.abs(p.y - r.cy());\n                        if (dx < r.width() / 2 && dy < r.height() / 2) {\n                            (<any>p).node = node;\n                            break;\n                        }\n                    }\n                })\n                );\n\n            lines.forEach((l, li) => {\n                // create vertices at the intersections of nodes and lines\n                this.nodes.forEach((v, i) => {\n                    v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach((intersect, j) => {\n                        //console.log(li+','+i+','+j+':'+intersect.x + ',' + intersect.y);\n                        var p = new Vert(this.verts.length, intersect.x, intersect.y, v, l);\n                        this.verts.push(p);\n                        l.verts.push(p);\n                        v.ports.push(p);\n                    });\n                });\n\n                // split lines into edges joining vertices\n                var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;\n                var delta = (a, b) => isHoriz ? b.x - a.x : b.y - a.y;\n                l.verts.sort(delta);\n                for (var i = 1; i < l.verts.length; i++) {\n                    var u = l.verts[i - 1], v = l.verts[i];\n                    if (u.node && u.node === v.node && u.node.leaf) continue;\n                    this.edges.push({ source: u.id, target: v.id, length: Math.abs(delta(u, v)) });\n                }\n            });\n\n\n\n        }\n\n        // find path from v to root including both v and root\n        private findLineage(v) {\n            var lineage = [v];\n            do {\n                v = v.parent;\n                lineage.push(v);\n            } while (v !== this.root);\n            return lineage.reverse();\n        }\n\n        // find path connecting a and b through their lowest common ancestor\n        private findAncestorPathBetween(a, b) {\n            var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;\n            while (aa[i] === ba[i]) i++;\n            // i-1 to include common ancestor only once (as first element)\n            return { commonAncestor: aa[i - 1], lineages: aa.slice(i).concat(ba.slice(i)) };\n        }\n\n        // when finding a path between two nodes a and b, siblings of a and b on the\n        // paths from a and b to their least common ancestor are obstacles\n        siblingObstacles(a, b) {\n            var path = this.findAncestorPathBetween(a, b);\n            var lineageLookup = {};\n            path.lineages.forEach(v=> lineageLookup[v.id] = {});\n            var obstacles = path.commonAncestor.children.filter(v=> !(v in lineageLookup));\n\n            path.lineages\n                .filter(v=> v.parent !== path.commonAncestor)\n                .forEach(v=> obstacles = obstacles.concat(v.parent.children.filter(c=> c !== v.id)));\n\n            return obstacles.map(v=> this.nodes[v]);\n        }\n\n        // for the given routes, extract all the segments orthogonal to the axis x\n        // and return all them grouped by x position\n        static getSegmentSets(routes, x, y) {\n            // vsegments is a list of vertical segments sorted by x position\n            var vsegments = [];\n            for (var ei = 0; ei < routes.length; ei++) {\n                var route = routes[ei];\n                for (var si = 0; si < route.length; si++) {\n                    var s = <any>route[si];\n                    s.edgeid = ei;\n                    s.i = si;\n                    var sdx = s[1][x] - s[0][x];\n                    if (Math.abs(sdx) < 0.1) {\n                        vsegments.push(s);\n                    }\n                }\n            }\n            vsegments.sort((a, b) => a[0][x] - b[0][x]);\n\n            // vsegmentsets is a set of sets of segments grouped by x position\n            var vsegmentsets = [];\n            var segmentset = null;\n            for (var i = 0; i < vsegments.length; i++) {\n                var s = vsegments[i];\n                if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {\n                    segmentset = { pos: s[0][x], segments: [] };\n                    vsegmentsets.push(segmentset);\n                }\n                segmentset.segments.push(s);\n            }\n            return vsegmentsets;\n        }\n\n        // for all segments in this bundle create a vpsc problem such that\n        // each segment's x position is a variable and separation constraints\n        // are given by the partial order over the edges to which the segments belong\n        // for each pair s1,s2 of segments in the open set:\n        //   e1 = edge of s1, e2 = edge of s2\n        //   if leftOf(e1,e2) create constraint s1.x + gap <= s2.x\n        //   else if leftOf(e2,e1) create cons. s2.x + gap <= s1.x\n        static nudgeSegs(x: string, y: string, routes, segments, leftOf, gap: number) {\n            var n = segments.length;\n            if (n <= 1) return;\n            var vs = segments.map(s => new Variable(s[0][x]));\n            var cs = [];\n            for (var i = 0; i < n; i++) {\n                for (var j = 0; j < n; j++) {\n                    if (i === j) continue;\n                    var s1 = segments[i],\n                        s2 = segments[j],\n                        e1 = s1.edgeid,\n                        e2 = s2.edgeid,\n                        lind = -1,\n                        rind = -1;\n                    // in page coordinates (not cartesian) the notion of 'leftof' is flipped in the horizontal axis from the vertical axis\n                    // that is, when nudging vertical segments, if they increase in the y(conj) direction the segment belonging to the\n                    // 'left' edge actually needs to be nudged to the right\n                    // when nudging horizontal segments, if the segments increase in the x direction\n                    // then the 'left' segment needs to go higher, i.e. to have y pos less than that of the right\n                    if (x == 'x') {\n                        if (leftOf(e1, e2)) {\n                            //console.log('s1: ' + s1[0][x] + ',' + s1[0][y] + '-' + s1[1][x] + ',' + s1[1][y]);\n                            if (s1[0][y] < s1[1][y]) {\n                                lind = j, rind = i;\n                            } else {\n                                lind = i, rind = j;\n                            }\n                        }\n                    } else {\n                        if (leftOf(e1, e2)) {\n                            if (s1[0][y] < s1[1][y]) {\n                                lind = i, rind = j;\n                            } else {\n                                lind = j, rind = i;\n                            }\n                        }\n                    }\n                    if (lind >= 0) {\n                        //console.log(x+' constraint: ' + lind + '<' + rind);\n                        cs.push(new Constraint(vs[lind], vs[rind], gap));\n                    }\n                }\n            }\n            var solver = new Solver(vs, cs);\n            solver.solve();\n            vs.forEach((v, i) => {\n                var s = segments[i];\n                var pos = v.position();\n                s[0][x] = s[1][x] = pos;\n                var route = routes[s.edgeid];\n                if (s.i > 0) route[s.i - 1][1][x] = pos;\n                if (s.i < route.length - 1) route[s.i + 1][0][x] = pos;\n            });\n        }\n\n        static nudgeSegments(routes, x: string, y: string, leftOf: (e1: number, e2: number) => boolean, gap: number) {\n            var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);\n            // scan the grouped (by x) segment sets to find co-linear bundles\n            for (var i = 0; i < vsegmentsets.length; i++) {\n                var ss = vsegmentsets[i];\n                var events = [];\n                for (var j = 0; j < ss.segments.length; j++) {\n                    var s = ss.segments[j];\n                    events.push({ type: 0, s: s, pos: Math.min(s[0][y], s[1][y]) });\n                    events.push({ type: 1, s: s, pos: Math.max(s[0][y], s[1][y]) });\n                }\n                events.sort((a, b) => a.pos - b.pos + a.type - b.type);\n                var open = [];\n                var openCount = 0;\n                events.forEach(e=> {\n                    if (e.type === 0) {\n                        open.push(e.s);\n                        openCount++;\n                    } else {\n                        openCount--;\n                    }\n                    if (openCount == 0) {\n                        GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);\n                        open = [];\n                    }\n                });\n            }\n        }\n\n        // obtain routes for the specified edges, nicely nudged apart\n        // warning: edge paths may be reversed such that common paths are ordered consistently within bundles!\n        // @param edges list of edges\n        // @param nudgeGap how much to space parallel edge segements\n        // @param source function to retrieve the index of the source node for a given edge\n        // @param target function to retrieve the index of the target node for a given edge\n        // @returns an array giving, for each edge, an array of segments, each segment a pair of points in an array\n        routeEdges<Edge>(edges: Edge[], nudgeGap: number, source: (e: Edge) => number, target: (e: Edge) => number): Point[][][] {\n            var routePaths = edges.map(e=> this.route(source(e), target(e)));\n            var order = GridRouter.orderEdges(routePaths);\n            var routes = routePaths.map(function (e) { return GridRouter.makeSegments(e); });\n            GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);\n            GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);\n            GridRouter.unreverseEdges(routes, routePaths);\n            return routes;\n        }\n\n        // path may have been reversed by the subsequence processing in orderEdges\n        // so now we need to restore the original order\n        static unreverseEdges(routes, routePaths) {\n            routes.forEach((segments, i) => {\n                var path = routePaths[i];\n                if ((<any>path).reversed) {\n                    segments.reverse(); // reverse order of segments\n                    segments.forEach(function (segment) {\n                        segment.reverse();  // reverse each segment\n                    });\n                }\n            });\n        }\n\n        static angleBetween2Lines(line1: Point[], line2: Point[]): number {\n            var angle1 = Math.atan2(line1[0].y - line1[1].y,\n                line1[0].x - line1[1].x);\n            var angle2 = Math.atan2(line2[0].y - line2[1].y,\n                line2[0].x - line2[1].x);\n            var diff = angle1 - angle2;\n            if (diff > Math.PI || diff < -Math.PI) {\n                diff = angle2 - angle1;\n            }\n            return diff;\n        }\n\n        // does the path a-b-c describe a left turn?\n        private static isLeft(a, b, c) {\n            return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) <= 0;\n        }\n\n        // for the given list of ordered pairs, returns a function that (efficiently) looks-up a specific pair to\n        // see if it exists in the list\n        private static getOrder(pairs: { l: number; r: number }[]): (l: number, r: number) => boolean {\n            var outgoing = {};\n            for (var i = 0; i < pairs.length; i++) {\n                var p = pairs[i];\n                if (typeof outgoing[p.l] === 'undefined') outgoing[p.l] = {};\n                outgoing[p.l][p.r] = true;\n            }\n            return (l, r) => typeof outgoing[l] !== 'undefined' && outgoing[l][r];\n        }\n\n        // returns an ordering (a lookup function) that determines the correct order to nudge the\n        // edge paths apart to minimize crossings\n        static orderEdges(edges) {\n            var edgeOrder = [];\n            for (var i = 0; i < edges.length - 1; i++) {\n                for (var j = i + 1; j < edges.length; j++) {\n                    var e = edges[i],\n                        f = edges[j],\n                        lcs = new LongestCommonSubsequence(e, f);\n                    var u, vi, vj;\n                    if (lcs.length === 0)\n                        continue; // no common subpath\n                    if (lcs.reversed) {\n                        // if we found a common subpath but one of the edges runs the wrong way,\n                        // then reverse f.\n                        f.reverse();\n                        f.reversed = true;\n                        lcs = new LongestCommonSubsequence(e, f);\n                    }\n                    if ((lcs.si <= 0 || lcs.ti <= 0) &&\n                        (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {\n                        // the paths do not diverge, so make an arbitrary ordering decision\n                        edgeOrder.push({ l: i, r: j });\n                        continue;\n                    }\n                    if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {\n                        // if the common subsequence of the\n                        // two edges being considered goes all the way to the\n                        // end of one (or both) of the lines then we have to\n                        // base our ordering decision on the other end of the\n                        // common subsequence\n                        u = e[lcs.si + 1];\n                        vj = e[lcs.si - 1];\n                        vi = f[lcs.ti - 1];\n                    } else {\n                        u = e[lcs.si + lcs.length - 2];\n                        vi = e[lcs.si + lcs.length];\n                        vj = f[lcs.ti + lcs.length];\n                    }\n                    if (GridRouter.isLeft(u, vi, vj)) {\n                        edgeOrder.push({ l: j, r: i });\n                    } else {\n                        edgeOrder.push({ l: i, r: j });\n                    }\n                }\n            }\n            //edgeOrder.forEach(function (e) { console.log('l:' + e.l + ',r:' + e.r) });\n            return GridRouter.getOrder(edgeOrder);\n        }\n\n        // for an orthogonal path described by a sequence of points, create a list of segments\n        // if consecutive segments would make a straight line they are merged into a single segment\n        // segments are over cloned points, not the original vertices\n        static makeSegments(path: Point[]): Point[][] {\n            function copyPoint(p: Point) {\n                return <Point>{ x: p.x, y: p.y };\n            }\n            var isStraight = (a, b, c) => Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001;\n            var segments = [];\n            var a = copyPoint(path[0]);\n            for (var i = 1; i < path.length; i++) {\n                var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;\n                if (!c || !isStraight(a, b, c)) {\n                    segments.push([a, b]);\n                    a = b;\n                }\n            }\n            return segments;\n        }\n\n        // find a route between node s and node t\n        // returns an array of indices to verts\n        route(s: number, t: number): Point[] {\n            var source = this.nodes[<number>s], target = this.nodes[<number>t];\n            this.obstacles = this.siblingObstacles(source, target);\n\n            var obstacleLookup = {};\n            this.obstacles.forEach(o => obstacleLookup[o.id] = o);\n            this.passableEdges = this.edges.filter(e=> {\n                var u = this.verts[e.source],\n                    v = this.verts[e.target];\n                return !(u.node && u.node.id in obstacleLookup\n                    || v.node && v.node.id in obstacleLookup);\n            });\n\n            // add dummy segments linking ports inside source and target\n            for (var i = 1; i < source.ports.length; i++) {\n                var u = source.ports[0].id;\n                var v = source.ports[i].id;\n                this.passableEdges.push({\n                    source: u,\n                    target: v,\n                    length: 0\n                });\n            }\n            for (var i = 1; i < target.ports.length; i++) {\n                var u = target.ports[0].id;\n                var v = target.ports[i].id;\n                this.passableEdges.push({\n                    source: u,\n                    target: v,\n                    length: 0\n                });\n            }\n\n            var getSource = e=> e.source,\n                getTarget = e=> e.target,\n                getLength = e=> e.length;\n\n            var shortestPathCalculator = new Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);\n            var bendPenalty = (u, v, w) => {\n                var a = this.verts[u], b = this.verts[v], c = this.verts[w];\n                var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);\n                // don't count bends from internal node edges\n                if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)\n                    return 0;\n                return dx > 1 && dy > 1 ? 1000 : 0;\n            };\n\n            // get shortest path\n            var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(\n                source.ports[0].id, target.ports[0].id,\n                bendPenalty);\n\n            // shortest path is reversed and does not include the target port\n            var pathPoints = shortestPath.reverse().map(vi => this.verts[vi]);\n            pathPoints.push(this.nodes[target.id].ports[0]);\n\n            // filter out any extra end points that are inside the source or target (i.e. the dummy segments above)\n            return pathPoints.filter((v, i) =>\n                !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source\n                    || i > 0 && v.node === target && pathPoints[i - 1].node === target));\n        }\n\n        static getRoutePath(route: Point[][], cornerradius: number, arrowwidth: number, arrowheight: number): { routepath: string; arrowpath: string } {\n            var result = {\n                routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',\n                arrowpath: ''\n            };\n            if (route.length > 1) {\n                for (var i = 0; i < route.length; i++) {\n                    var li = route[i];\n                    var x = li[1].x, y = li[1].y;\n                    var dx = x - li[0].x;\n                    var dy = y - li[0].y;\n                    if (i < route.length - 1) {\n                        if (Math.abs(dx) > 0) {\n                            x -= dx / Math.abs(dx) * cornerradius;\n                        } else {\n                            y -= dy / Math.abs(dy) * cornerradius;\n                        }\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\n                        var l = route[i + 1];\n                        var x0 = l[0].x, y0 = l[0].y;\n                        var x1 = l[1].x;\n                        var y1 = l[1].y;\n                        dx = x1 - x0;\n                        dy = y1 - y0;\n                        var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;\n                        //console.log(cola.GridRouter.angleBetween2Lines(li, l))\n                        var x2, y2;\n                        if (Math.abs(dx) > 0) {\n                            x2 = x0 + dx / Math.abs(dx) * cornerradius;\n                            y2 = y0;\n                        } else {\n                            x2 = x0;\n                            y2 = y0 + dy / Math.abs(dy) * cornerradius;\n                        }\n                        var cx = Math.abs(x2 - x);\n                        var cy = Math.abs(y2 - y);\n                        result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';\n                    } else {\n                        var arrowtip = [x, y];\n                        var arrowcorner1, arrowcorner2;\n                        if (Math.abs(dx) > 0) {\n                            x -= dx / Math.abs(dx) * arrowheight;\n                            arrowcorner1 = [x, y + arrowwidth];\n                            arrowcorner2 = [x, y - arrowwidth];\n                        } else {\n                            y -= dy / Math.abs(dy) * arrowheight;\n                            arrowcorner1 = [x + arrowwidth, y];\n                            arrowcorner2 = [x - arrowwidth, y];\n                        }\n                        result.routepath += 'L ' + x + ' ' + y + ' ';\n                        if (arrowheight > 0) {\n                            result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\n                            + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\n                        }\n                    }\n                }\n            } else {\n                var li = route[0];\n                var x = li[1].x, y = li[1].y;\n                var dx = x - li[0].x;\n                var dy = y - li[0].y;\n                var arrowtip = [x, y];\n                var arrowcorner1, arrowcorner2;\n                if (Math.abs(dx) > 0) {\n                    x -= dx / Math.abs(dx) * arrowheight;\n                    arrowcorner1 = [x, y + arrowwidth];\n                    arrowcorner2 = [x, y - arrowwidth];\n                } else {\n                    y -= dy / Math.abs(dy) * arrowheight;\n                    arrowcorner1 = [x + arrowwidth, y];\n                    arrowcorner2 = [x - arrowwidth, y];\n                }\n                result.routepath += 'L ' + x + ' ' + y + ' ';\n                if (arrowheight > 0) {\n                    result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1]\n                    + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];\n                }\n            }\n            return result;\n        }\n    }\n","import {Calculator} from './shortestpaths'\nimport {Descent} from './descent'\nimport {Projection, GraphNode, Rectangle} from './rectangle'\nimport {Variable} from './vpsc'\nimport {jaccardLinkLengths, LinkLengthAccessor} from './linklengths'\n\nexport class Link3D {\n        length: number;\n        constructor(public source: number, public target: number) { }\n        actualLength(x: number[][]) {\n            return Math.sqrt(\n                x.reduce((c: number, v: number[]) => {\n                    const dx = v[this.target] - v[this.source];\n                    return c + dx * dx;\n                }, 0));\n        }\n    }\n    export class Node3D implements GraphNode {\n        // if fixed, layout will not move the node from its specified starting position\n        fixed: boolean;\n        width: number;\n        height: number;\n        px: number;\n        py: number;\n        bounds: Rectangle;\n        variable: Variable;\n        constructor(\n            public x: number = 0,\n            public y: number = 0,\n            public z: number = 0) { }\n    }\n    export class Layout3D {\n        static dims = ['x', 'y', 'z'];\n        static k = Layout3D.dims.length;\n        result: number[][];\n        constraints: any[] = null;\n\n        constructor(public nodes: Node3D[], public links: Link3D[], public idealLinkLength: number = 1) {\n            this.result = new Array(Layout3D.k);\n            for (var i = 0; i < Layout3D.k; ++i) {\n                this.result[i] = new Array(nodes.length);\n            }\n            nodes.forEach((v, i) => {\n                for (var dim of Layout3D.dims) {\n                    if (typeof v[dim] == 'undefined') v[dim] = Math.random();\n                }\n                this.result[0][i] = v.x;\n                this.result[1][i] = v.y;\n                this.result[2][i] = v.z;\n            });\n        };\n\n        linkLength(l: Link3D): number {\n            return l.actualLength(this.result);\n        }\n\n        useJaccardLinkLengths: boolean = true;\n\n        descent: Descent;\n        start(iterations: number = 100): Layout3D {\n            const n = this.nodes.length;\n\n            var linkAccessor = new LinkAccessor();\n\n            if (this.useJaccardLinkLengths)\n                jaccardLinkLengths(this.links, linkAccessor, 1.5);\n\n            this.links.forEach(e => e.length *= this.idealLinkLength);\n\n            // Create the distance matrix that Cola needs\n            const distanceMatrix = (new Calculator(n, this.links,\n                e=> e.source, e=> e.target, e => e.length)).DistanceMatrix();\n\n            const D = Descent.createSquareMatrix(n, (i, j) => distanceMatrix[i][j]);\n\n            // G is a square matrix with G[i][j] = 1 iff there exists an edge between node i and node j\n            // otherwise 2.\n            var G = Descent.createSquareMatrix(n, function () { return 2 });\n            this.links.forEach(({ source, target }) => G[source][target] = G[target][source] = 1);\n\n            this.descent = new Descent(this.result, D);\n            this.descent.threshold = 1e-3;\n            this.descent.G = G;\n            //let constraints = this.links.map(e=> <any>{\n            //    axis: 'y', left: e.source, right: e.target, gap: e.length*1.5\n            //});\n            if (this.constraints)\n                this.descent.project = new Projection(<GraphNode[]>this.nodes, null, null, this.constraints).projectFunctions();\n\n            for (var i = 0; i < this.nodes.length; i++) {\n                var v = this.nodes[i];\n                if (v.fixed) {\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\n                }\n            }\n\n            this.descent.run(iterations);\n            return this;\n        }\n\n        tick(): number {\n            this.descent.locks.clear();\n            for (var i = 0; i < this.nodes.length; i++) {\n                var v = this.nodes[i];\n                if (v.fixed) {\n                    this.descent.locks.add(i, [v.x, v.y, v.z]);\n                }\n            }\n            return this.descent.rungeKutta();\n        }\n    }\n\n    class LinkAccessor implements LinkLengthAccessor<any> {\n        getSourceIndex(e: any): number { return e.source; }\n        getTargetIndex(e: any): number { return e.target; }\n        getLength(e: any): number { return e.length; }\n        setLength(e: any, l: number) { e.length = l; }\n    }\n","import {D3StyleLayoutAdaptor} from './d3v3adaptor'\nimport {D3Context, D3NextStyleLayoutAdaptor} from './d3Nextadaptor'\nimport { Layout, EventType, Event } from './layout';\n\nexport { D3Context } from './d3Nextadaptor';\n\nexport interface D3v3Context { version: string };\n\nexport interface ID3StyleLayoutAdaptor {\n    trigger(e: Event): void;\n    kick(): void;\n    drag: () => any;\n\n    on(eventType: EventType | string, listener: () => void): ID3StyleLayoutAdaptor;\n}\n\n\n/**\n * provides an interface for use with d3:\n * Correct way to create way to construct the d3 cola object is to pass the d3 object into the adaptor function, like so:\n *\n *   `var d3cola = cola.d3adaptor(d3);`\n *\n * Internally, it will figure out if d3 is version 3 or 4 from the version tag and set up the right event forwarding. Defaults to version 3 if the d3 object is not passed.\n * - uses the d3 event system to dispatch layout events such as:\n *   o \"start\" (start layout process)\n *   o \"tick\" (after each layout iteration)\n *   o \"end\" (layout converged and complete).\n * - uses the d3 timer to queue layout iterations.\n * - sets up d3.behavior.drag to drag nodes\n *   o use `node.call(<the returned instance of Layout>.drag)` to make nodes draggable\n * returns an instance of the cola.Layout itself with which the user\n * can interact directly.\n */\nexport function d3adaptor(d3Context?: D3Context | D3v3Context): Layout & ID3StyleLayoutAdaptor {\n    if (!d3Context || isD3V3(d3Context)) {\n        return new D3StyleLayoutAdaptor(d3Context);\n    }\n    return new D3NextStyleLayoutAdaptor(d3Context);\n}\n\nfunction isD3V3(d3Context: D3Context | D3v3Context): d3Context is D3v3Context {\n    const v3exp = /^3\\./;\n    return (<any>d3Context).version && (<any>d3Context).version.match(v3exp) !== null;\n}\n","import {Node, Link, Layout} from './layout'\nimport {GridRouter} from './gridrouter'\nimport {Point} from './geom'\n\n/**\n * @property nudgeGap spacing between parallel edge segments\n * @property margin space around nodes\n * @property groupMargin space around groups\n */\nexport function gridify(pgLayout, nudgeGap: number, margin: number, groupMargin: number) {\n    pgLayout.cola.start(0, 0, 0, 10, false);\n    let gridrouter = route(pgLayout.cola.nodes(), pgLayout.cola.groups(), margin, groupMargin);\n    return gridrouter.routeEdges<any>(pgLayout.powerGraph.powerEdges, nudgeGap, e=> e.source.routerNode.id, e=> e.target.routerNode.id);\n}\n\nfunction route(nodes, groups, margin: number, groupMargin: number) {\n    nodes.forEach(d => {\n        d.routerNode = <any>{\n            name: d.name,\n            bounds: d.bounds.inflate(-margin)\n        };\n    });\n    groups.forEach(d => {\n        d.routerNode = <any>{\n            bounds: d.bounds.inflate(-groupMargin),\n            children: (typeof d.groups !== 'undefined' ? d.groups.map(c=> nodes.length + c.id) : [])\n                .concat(typeof d.leaves !== 'undefined' ? d.leaves.map(c=> c.index) : [])\n        };\n    });\n    let gridRouterNodes = nodes.concat(groups).map((d, i) => {\n        d.routerNode.id = i;\n        return d.routerNode;\n    });\n    return new GridRouter(gridRouterNodes, {\n        getChildren: (v: any) => v.children,\n        getBounds: v => v.bounds\n    }, margin - groupMargin);\n}\n\nexport function powerGraphGridLayout(\n    graph: { nodes: Node[], links: Link<Node>[] },\n    size: number[],\n    grouppadding: number)\n{\n    // compute power graph\n    var powerGraph;\n    graph.nodes.forEach((v,i) => (<any>v).index = i);\n    new Layout()\n        .avoidOverlaps(false)\n        .nodes(graph.nodes)\n        .links(graph.links)\n        .powerGraphGroups(function (d) {\n            powerGraph = d;\n            powerGraph.groups.forEach(v=> v.padding = grouppadding);\n        });\n\n    // construct a flat graph with dummy nodes for the groups and edges connecting group dummy nodes to their children\n    // power edges attached to groups are replaced with edges connected to the corresponding group dummy node\n    var n = graph.nodes.length;\n    var edges = [];\n    var vs = graph.nodes.slice(0);\n    vs.forEach((v, i) => (<any>v).index = i);\n    powerGraph.groups.forEach(g => {\n        var sourceInd = g.index = g.id + n;\n        vs.push(g);\n        if (typeof g.leaves !== 'undefined')\n            g.leaves.forEach(v => edges.push({ source: sourceInd, target: v.index }));\n        if (typeof g.groups !== 'undefined')\n            g.groups.forEach(gg => edges.push({ source: sourceInd, target: gg.id + n }));\n    });\n    powerGraph.powerEdges.forEach(e=> {\n        edges.push({ source: e.source.index, target: e.target.index });\n    });\n\n    // layout the flat graph with dummy nodes and edges\n    new Layout()\n        .size(size)\n        .nodes(vs)\n        .links(edges)\n        .avoidOverlaps(false)\n        .linkDistance(30)\n        .symmetricDiffLinkLengths(5)\n        .convergenceThreshold(1e-4)\n        .start(100, 0, 0, 0, false);\n\n    // final layout taking node positions from above as starting positions\n    // subject to group containment constraints\n    // and then gridifying the layout\n    return {\n        cola:\n            new Layout()\n            .convergenceThreshold(1e-3)\n            .size(size)\n            .avoidOverlaps(true)\n            .nodes(graph.nodes)\n            .links(graph.links)\n        //.flowLayout('y', 30)\n            .groupCompactness(1e-4)\n            .linkDistance(30)\n            .symmetricDiffLinkLengths(5)\n            .powerGraphGroups(function (d) {\n                powerGraph = d;\n                powerGraph.groups.forEach(function (v) {\n                    v.padding = grouppadding\n                });\n            }).start(50, 0, 100, 0, false),\n        powerGraph: powerGraph\n    };\n}\n"],"names":["PowerEdge","source","target","type","Configuration","n","edges","linkAccessor","rootGroup","modules","Array","roots","initModulesFromGroup","push","ModuleSet","i","add","this","Module","R","length","forEach","e","s","_this","getSourceIndex","t","getTargetIndex","getType","outgoing","incoming","group","moduleSet","leaves","node","module","id","groups","j","child","definition","prop","hasOwnProperty","LinkSets","merge","a","b","k","inInt","intersection","outInt","children","m","update","o","forAll","ms","linktype","nls","remove","count","rootMerges","rs","merges","ctr","i_","nEdges","greedyMerge","sort","getGroupHierarchy","retargetedEdges","toGroups","isLeaf","g","gid","isIsland","isPredefined","allEdges","_this2","es","getEdges","edgetype","_this3","Object","keys","table","other","result","v","intersectionCount","contains","f","mid","vs","forAllModules","sets","Number","lt","getGroups","nodes","links","la","c","powerEdges","end","unionCount","u","computeLinkLengths","w","neighbours","addNeighbours","getNeighbours","l","setLength","symmetricDiffLinkLengths","Math","sqrt","jaccardLinkLengths","min","generateDirectedEdgeConstraints","axis","components","stronglyConnectedComponents","constraints","ui","vi","left","right","gap","getMinSeparation","numVertices","index","stack","strongConnect","lowlink","onStack","out","component","pop","map","Locks","x","locks","clear","isEmpty","apply","Descent","D","G","PseudoRandom","H","Hd","d","ia","ib","xtmp","minD","MAX_VALUE","createSquareMatrix","M","offsetDir","random","getNextBetween","computeDerivatives","d2","Huu","maxH","maxDisplaces","distanceSquared","dx","rd","distance","idealDistance","weight","isFinite","idealDistSquared","gs","distanceCubed","hs","console","log","max","r","snapGridSize","snapStrength","numNodes","numGridSnapNodes","xiu","q","abs","scaleSnapByMaxH","p","dotProd","rightMultiply","computeStepSize","numerator","denominator","reduceStress","alpha","takeDescentStep","computeStress","copy","stepAndProject","x0","stepSize","project","mApply","matrixApply","computeNextPosition","beta","run","iterations","stress","converged","rungeKutta","threshold","disp","_this4","nMinus1","rl","seed","getNext","range","PositionStats","scale","addVariable","ai","wi","AB","offset","AD","desiredPosition","A2","getPosn","Constraint","equality","slack","unsatisfiable","position","Variable","dfdv","block","ps","posn","visitNeighbours","prev","ff","next","active","cOut","cIn","Block","vars","updateWeightedPosition","compute_lm","postAction","_dfdv","lm","populateSplitBlock","traverse","visit","acc","findMinLM","findMinLMBetween","lv","rv","findPath","to","endFound","isActiveDirectedPathBetween","split","createSplitBlock","startVar","splitBetween","vl","vr","bs","constraint","lb","rb","mergeAcross","dist","cost","sum","Blocks","list","blockInd","insert","last","swapBlock","updateBlockPositions","inactive","Solver","LAGRANGIAN_TOLERANCE","nb","_this5","cs","setStartingPositions","setDesiredPositions","mostViolated","minSlack","deletePoint","ZERO_UPPERBOUND","satisfy","solve","lastcost","TreeBase","data","res","_root","iter","iterator","_comparator","_cursor","_ancestors","get_child","size","find","lowerBound","_bound","upperBound","cmp","Iterator","each","cb","it","reach","cur","tree","_tree","root","_minNode","save","_maxNode","start","Node","red","dir","set_child","val","RBTree","comparator","ret","head","undefined","gp","ggp","is_red","dir2","single_rotate","double_rotate","found","sr","sibling","gpc","computeGroupBounds","bounds","reduce","union","Rectangle","empty","inflate","padding","X","y","Y","POSITIVE_INFINITY","NEGATIVE_INFINITY","cx","cy","overlapX","ux","vx","overlapY","uy","vy","setXCentre","setYCentre","dy","width","height","lineIntersections","x1","y1","x2","y2","sides","intersections","lineIntersection","rayIntersection","ints","vertices","x3","y3","x4","y4","dx12","dx34","dy12","dy34","dx31","dy31","pad","makeEdgeBetween","ah","si","ti","al","sourceIntersection","targetIntersection","arrowStart","makeEdgeTo","pos","makeRBTree","Event","isOpen","compareEvents","xRect","getCentre","getOpen","getClose","getSize","makeRect","open","close","center","findNeighbours","scanline","forward","reverse","findIter","uovervX","yRect","generateGroupConstraints","minSep","isContained","gn","ln","childConstraints","ccs","concat","minVar","maxVar","variable","generateConstraints","gapAdjustment","rect","N","assert","events","makeConstraint","sep","mkcon","generateXConstraints","generateYConstraints","generateXGroupConstraints","generateYGroupConstraints","IndexedVariable","Projection","avoidOverlaps","variables","createConstraints","w2","h2","stiffness","createSeparation","makeFeasible","dim","offsets","nextPos","createAlignment","xConstraints","yConstraints","slice","isSep","filter","setupVariablesAndBounds","y0","desired","getDesired","fixed","fixedWeight","h","ix","iy","xProject","px","xmin","xmax","p2","yProject","py","ymin","ymax","projectFunctions","_this6","updateNodeBounds","updateGroupBounds","starting","solver","PairingHeap","elem","subheaps","toString","selector","str","needComma","subheap","isHeap","lessThan","every","obj","heap2","removeMin","mergePairs","firstPair","remaining","decreaseKey","newValue","setHeapNode","newHeap","pairingNode","PriorityQueue","top","arg","reduceKey","heapNode","newKey","Neighbour","QueueEntry","Calculator","getLength","DistanceMatrix","dijkstraNeighbours","DistancesFromNode","PathFromNodeToNode","PathFromNodeToNodeWithPrevCost","prevCost","qu","visitedFrom","neighbour","viduid","cc","path","dest","Point","LineSegment","PolyPoint","isLeft","P0","P1","P2","above","vj","below","Rtangent_PointPolyC","P","V","dnC","floor","Ltangent_PointPolyC","tangent_PolyPolyC","W","t1","t2","cmp1","cmp2","ix1","ix2","done","RLtangent_PolyPolyC","BiTangent","BiTangents","TVGPoint","VisibilityVertex","polyid","polyvertid","vv","VisibilityEdge","TangentVisibilityGraph","g0","E","Pi","Pj","tangents","addEdgeIfVisible","i1","i2","intersectsPolys","addPoint","Vclosed","poly","rtan","ltan","intersects","int","bt","v1","v2","v3","w1","w3","v1v2w2","v2w1w2","v2w2w3","w1w2v2","w2v1v2","w2v2v3","ll","rr","lr","isAnyPInQ","isPointInsidePoly","EventType","packingOptions","applyPacking","graphs","node_size","desired_ratio","centerGraph","svg_width","svg_height","real_width","real_height","min_width","global_bottom","line","step","max_width","put_rect","parent","space_left","bottom","graph","min_x","min_y","max_x","max_y","array","calculate_bb","curr_best_f","curr_best","get_entire_width","iterationCounter","f_x1","f_x2","flag","df","put_nodes_to_right_positions","separateGraphs","marks","ways","clusters","link","n1","n2","explore_node","is_new","adjacent","isGroup","Layout","setLinkLength","_linkType","on","listener","event","trigger","kick","tick","_alpha","_threshold","_running","_lastStress","_nodes","_descent","s1","updateNodePositions","_links","_groups","_rootGroup","gi","powerGraphGroups","powergraph","arguments","_avoidOverlaps","handleDisconnected","_handleDisconnected","flowLayout","minSeparation","_directedLinkConstraints","_constraints","distanceMatrix","_distanceMatrix","_canvasSize","defaultNodeSize","_defaultNodeSize","groupCompactness","_groupCompactness","linkDistance","_linkDistance","_linkLengthCalculator","linkType","convergenceThreshold","getLinkLength","getLinkType","idealLength","initialUnconstrainedIterations","initialUserConstraintIterations","initialAllConstraintsIterations","gridSnapIterations","keepRunning","distances","ao","strength","addAttraction","curConstraints","initialLayout","separateOverlappingComponents","G0","resume","gg","stop","prepareEdgeRouting","nodeMargin","_visibilityGraph","routeEdge","edge","draw","lineData","vg2","port1","port2","shortestPath","route","innerBounds","linkId","dragStart","storeOffset","dragOrigin","stopNode","origin","_dragGroupOffsetX","_dragGroupOffsetY","drag","dragEnd","mouseOver","mouseOut","LayoutAdaptor","options","dragstart","dragend","eventType","D3StyleLayoutAdaptor","d3Context","self","d3","dispatch","d3layout","behavior","call","d3event","timer","D3NextStyleLayoutAdaptor","subject","_Layout","NodeWrapper","leaf","Vert","LongestCommonSubsequence","mf","findMatch","tr","mr","reversed","match","getSequence","GridRouter","originalnodes","accessor","groupPadding","getBounds","getChildren","cols","getGridLines","rows","ports","backToFront","getDepth","colMids","midPoints","rowMids","rowx","rowX","coly","colY","hlines","vlines","lines","verts","li","intersect","isHoriz","delta","avg","columns","ls","overlapping","toUpperCase","col","splice","indexOf","depth","mids","findLineage","lineage","findAncestorPathBetween","aa","ba","commonAncestor","lineages","siblingObstacles","lineageLookup","obstacles","getSegmentSets","routes","vsegments","ei","edgeid","vsegmentsets","segmentset","segments","nudgeSegs","leftOf","e1","e2","lind","rind","nudgeSegments","ss","openCount","routeEdges","nudgeGap","routePaths","order","orderEdges","makeSegments","unreverseEdges","segment","angleBetween2Lines","line1","line2","angle1","atan2","angle2","diff","PI","getOrder","pairs","edgeOrder","lcs","copyPoint","isStraight","obstacleLookup","passableEdges","pathPoints","getRoutePath","cornerradius","arrowwidth","arrowheight","arrowcorner1","arrowcorner2","routepath","arrowpath","angle","arrowtip","Link3D","actualLength","Layout3D","idealLinkLength","dims","z","linkLength","LinkAccessor","useJaccardLinkLengths","descent","S","minmax","maxmin","maxmax","bot","version","isD3V3","pgLayout","margin","groupMargin","cola","routerNode","name","gridRouterNodes","powerGraph","grouppadding","sourceInd","spans","desiredCenter","leftMost","rightMost","leftMostSize","rightMostSize","vLower","vUpper","newCenters"],"mappings":"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"}